<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.21" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel='stylesheet' href='//fonts.proxy.ustclug.org/css?family=Open+Sans|Marcellus+SC'>
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.7.0/styles/github.min.css">
    <link rel="stylesheet" href="http://lovelock.coding.me/css/styles.css">
    <link rel="stylesheet" href="http://lovelock.coding.me/css/custom.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://lovelock.coding.me//index.xml">

    
    <title>排序算法 &lt;一&gt; - Me &amp; Web</title>
    <meta property='og:title' content="排序算法 &lt;一&gt; - Me &amp; Web">
    <meta property="og:type" content="article">
    

    <meta property="og:url" content="http://lovelock.coding.me/algo/sorting-algorithms/">
    
    

  </head>

  <body>

    <header class="site">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://lovelock.coding.me/">Me &amp; Web&nbsp;&nbsp;致力于创作可操作性更好的文章</a>
          </div>

          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="http://lovelock.coding.me/about">关于作者</a></li>
              
              
              
              <li><a href="http://lovelock.coding.me/categories/">分类</a></li>
              
              
              
              <li><a href="http://lovelock.coding.me/tags/">标签</a></li>
              
              
              
              <li><a href="http://lovelock.coding.me/">首页</a></li>
              
              
            </ul>
            
          </div>

        </div>
      </nav>
    </header>

    <div class="site">
      <div class="container">



<div class="single">

    <div class="row">
        <div class="col-md-8">

            <article class="single" itemscope="itemscope" itemtype="http://schema.org/Article">

                <meta itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" content="http://lovelock.coding.me/"/>
                <meta itemprop="dateModified" content="2017-02-13T15:21:01&#43;08:00">
                <meta itemprop="headline" content="排序算法 &lt;一&gt;">
                <meta itemprop="description" content="就让我再啃一下一直以来最头疼的问题吧。 冒泡排序(bubble sorting) 刚才突然想通了，之前竟然不知道为什么大家都说冒泡是最简单的。。。难道是我智商不">
                <meta itemprop="url" content="http://lovelock.coding.me/algo/sorting-algorithms/">
                <div itemprop="image" itemscope itemtype="https://schema.org/ImageObject">
                    <meta itemprop="url" content="http://lovelock.coding.me/images/default.jpg" />
                    <meta itemprop="width" content="800">
                    <meta itemprop="height" content="800">
                </div>
                <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
                    <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
                        <meta itemprop="url" content="http://lovelock.coding.me/images/logo.jpg">
                        <meta itemprop="width" content="100">
                        <meta itemprop="height" content="100">
                    </div>
                    <meta itemprop="name" content="Me &amp; Web">
                </div>
                <div itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <meta itemprop="name" content="Frost Wong">
                </div>

                <header class="article-header">
                    <time itemprop="datePublished" pubdate="pubdate" datetime="2017-02-13T15:21:01&#43;08:00">Mon, Feb 13, 2017</time>
                    <h1 class="article-title">排序算法 &lt;一&gt;</h1>
                </header>

                
                    <div class="article-body">
                        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#冒泡排序-bubble-sorting">冒泡排序(bubble sorting)</a></li>
<li><a href="#鸡尾酒排序-cocktail-sorting">鸡尾酒排序(cocktail sorting)</a></li>
<li><a href="#选择排序-selection-sorting">选择排序（selection sorting)</a></li>
<li><a href="#插入排序-insertion-sorting">插入排序(insertion sorting)</a></li>
<li><a href="#二分插入排序">二分插入排序</a></li>
<li><a href="#希尔排序-shell-sorting">希尔排序（shell sorting)</a></li>
</ul></li>
</ul>
</nav>
                    </div>
                

                <div class="article-body" itemprop="articleBody">
                    

<p>就让我再啃一下一直以来最头疼的问题吧。</p>

<h2 id="冒泡排序-bubble-sorting">冒泡排序(bubble sorting)</h2>

<p>刚才突然想通了，之前竟然不知道为什么大家都说冒泡是最简单的。。。难道是我智商不够了么</p>

<p>假设有这样一组数字$a = [2, 3, 8, 1, 5, 7]$。要对它进行排序，按照冒泡排序的做法最终是要这样做：</p>

<ol>
<li><p>设数组的索引是$i$，如果$a[i] &gt; a[i+1]$，那么就让二者交换位置</p></li>

<li><p>紧接着让$a[i+1]$和$a[i+2]$做比较，要知道这时$a[i+1]$已经是$a[i]$和$a[i+1]$中较大的了，按照前面的做法把二者中较大的放在后面</p></li>

<li><p>这样做一轮最大的数字就会在新数组最后了</p></li>

<li><p>但前面5位的位置依然是乱序的，要按前面3步的规则重新排一遍。因为最后一位已经是最大无疑，就不需要参与排序了</p></li>

<li><p>第一轮排序得到一个最大的，第二轮得到第二大，当第二小的确定以后，第一小的也随之确定，所以一共需要做$n-1$轮排序</p></li>
</ol>

<p>​</p>

<p>原理清楚了，用代码把它描述出来就是这样了（为了突出一个逼格，一定要用C啊）：</p>

<pre><code class="language-c">   #include &lt;stdio.h&gt;

   void swap(int a[], int i, int j)
   {
       int tmp = a[i];
       a[i] = a[j];
       a[j] = tmp;
   }

   void bubble_sort(int a[], int len)
   {
       for (int j = 0; j &lt; len - 1; j++) {
           for (int i = 0; i &lt; len - 1 - j; i++) {
               if (a[i] &gt; a[i+1]) {
                   swap(a, i, i+1);
               }
           }
       }
   }

   int main()
   {
       int a[] = {2, 3, 8, 1, 5, 7};
       int n = sizeof(a) / sizeof(int);
       int i;

       puts(&quot;原始数组: &quot;);
       for (i = 0; i &lt; n; i++) {
           printf(&quot;%d\t&quot;, a[i]);
       }
       puts(&quot;&quot;);
       printf(&quot;数组长度: %d\t&quot;, n);

       bubble_sort(a, n);

       puts(&quot;排序后数组: &quot;);
       for (i = 0; i &lt; n; i++) {
           printf(&quot;%d\t&quot;, a[i]);
       }
       puts(&quot;&quot;);

       return 0;
   }
</code></pre>

<p>​</p>

<p>为了让自己不忘记最核心的代码，这里详细的描述一下：</p>

<ol>
<li>最外层循环是说要进行<code>n-1</code>轮排序才能完成</li>
<li>内层循环是说外层循环每进行一轮，需要进行比较的数字就会少一组，也就是前面提到的，最大值已经确定了，后面的排序它就不需要参与了</li>
<li>然后就是最简单的交换顺序了</li>
</ol>

<p>这样理解下来，冒泡排序果然是最简单的了。</p>

<p>再呈上PHP版本：</p>

<pre><code class="language-php">   &lt;?php

   function swap(array $a, $i, $j)
   {
       $tmp = $a[$i];
       $a[$i] = $a[$j];
       $a[$j] = $tmp;

       return $a;
   }

   function bubbleSort(array $a, $n)
   {
       for ($i = 0; $i &lt; $n; $i++) {
           for ($j = 0; $j &lt; $n - 1 - $i; $j++) {
               if ($a[$j] &gt; $a[$j+1]) {
                   $a = swap($a, $j, $j+1);
               }
           }
       }

       return $a;
   }

   $arr = [2, 3, 8, 1, 5, 7];
   $b = bubbleSort($arr, 6);
   var_export($b);

</code></pre>

<p>最近新学了golang，顺道也写一遍：</p>

<pre><code class="language-go">   package main

   import &quot;fmt&quot;

   func swap(a []int, i int, j int) {
   	tmp := a[i]
   	a[i] = a[j]
   	a[j] = tmp
   }

   func bubbleSort(a []int, n int) {
   	for i := 0; i &lt; n-1; i++ {
   		for j := 0; j &lt; n-1-i; j++ {
   			if a[j] &gt; a[j+1] {
   				swap(a, j, j+1)
   			}
   		}
   	}
   }

   func main() {
   	a := []int{2, 3, 8, 1, 5, 7}
   	bubbleSort(a, 6)
   	fmt.Println(a)
   }
</code></pre>

<h2 id="鸡尾酒排序-cocktail-sorting">鸡尾酒排序(cocktail sorting)</h2>

<p>鸡尾酒排序是冒泡排序的一种改进。前面说了，冒泡排序每轮排序仅仅选出其中最大的，而鸡尾酒排序则是在选出最大的以后，把最小的也选出来放在最前面。冒泡排序的时间复杂度是$(O(n^2)$，这样看起来鸡尾酒排序的时间复杂度应该是$O(\frac{n^2}{2})$，但没有那么记复杂度的，它和冒泡排序的时间复杂度是同一个数量级，但当需要排序的数字比较少时，通常鸡尾酒排序能获得更好的性能。</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

void swap(int a[], int i, int j)
{
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}

void cocktailSort(int a[], int n)
{
    int left = 0;
    int right = n - 1;
    while (left &lt; right) {
        for (int i = left; i &lt; right; i++) {
            if (a[i] &gt; a[i+1]) {
                swap(a, i, i+1);
            }
        }
        right--;

        for (int i = right; i &gt; left; i--) {
            if (a[i-1] &gt; a[i]) {
                swap(a, i-1, i);
            }
        }
        left++;
    }
}

int main()
{
    int a[] = {2, 3, 8, 1, 5, 7};
    int n = sizeof(a) / sizeof(int);
    int i;

    puts(&quot;原始数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);
    printf(&quot;数组长度: %d\n&quot;, n);

    cocktailSort(a, n);

    puts(&quot;排序后数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);

    return 0;
}
</code></pre>

<p>老规矩，PHP版本</p>

<pre><code class="language-php">&lt;?php

function swap(array $a, $i, $j)
{
    $tmp = $a[$i];
    $a[$i] = $a[$j];
    $a[$j] = $tmp;

    return $a;
}

function cocktailSort(array $a, $len)
{
    $left = 0;
    $right = $len - 1;

    while ($left &lt; $right) {
        for ($i = $left; $i &lt; $right; $i++) {
            if ($a[$i] &gt; $a[$i+1]) {
                $a = swap($a, $i, $i+1);
            }
        }
        $right--;

        for ($i = $right; $i &gt; $left; $i--) {
            if ($a[$i-1] &gt; $a[$i]) {
                $a = swap($a, $i-1, $i);
            }
        }
        $left++;
    }

    return $a;
}


$arr = [2, 3, 8, 1, 5, 7];

$b = cocktailSort($arr, 6);
var_export($b);
</code></pre>

<p>golang版本：</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func swap(a []int, i int, j int) {
	tmp := a[i]
	a[i] = a[j]
	a[j] = tmp
}

func cocktailSort(a []int, len int) {
	left := 0
	right := len - 1

	for left &lt; right {
		for i := left; i &lt; right; i++ {
			if a[i] &gt; a[i+1] {
				swap(a, i, i+1)
			}
		}
		right--

		for i := right; i &gt; left; i-- {
			if a[i-1] &gt; a[i] {
				swap(a, i-1, i)
			}
		}
		left++
	}
}

func main() {
	arr := []int{2, 3, 8, 1, 5, 7}
	cocktailSort(arr, 6)
	fmt.Println(arr)
}
</code></pre>

<h2 id="选择排序-selection-sorting">选择排序（selection sorting)</h2>

<p>这个现在看起来好像也很直观了（下面我按大家通常说的『趟』来替代前面说的『轮』）。</p>

<ol>
<li>每趟找出一个最小的放在最前面</li>
<li>如果有$n$个数，就要排$n-1$趟</li>
<li>对于每趟排序而言，设置一个flag $min$，用它标识该趟排序最小数的下标，第$i$趟排序开始时，前第$i-1$个数已经确定了，所以把$min = i$，后面把第$min$位数和它后面的所有数字比较，如果$a[min] &gt; a[min+1]$就把$min$设置为$min+1$</li>
<li>这一步最为关键，第3步找到了这趟排序的最小数，这步就要把放在第$i$位了，那原来第$i$位的数就当然和它交换位置了</li>
</ol>

<p>不多说，直接上代码：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

void swap(int a[], int i, int j)
{
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}

void selection_sort(int a[], int n)
{
    int min, i, j;

    for (i = 0; i &lt; n - 1; i++) { // 0 -&gt; (n-2) 一共(n-1)趟
        min = i;
        for (j = min + 1; j &lt; n; j++) {
            if (a[min] &gt; a[j]) {
                min = j;
            }
        }
        if (min != i) {
            swap(a, min, i);
        }
    }
}

int main()
{
    int a[] = {2, 3, 8, 1, 5, 7};
    int n = sizeof(a) / sizeof(int);
    int i;

    puts(&quot;原始数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);
    printf(&quot;数组长度: %d\t&quot;, n);

    selection_sort(a, n);

    puts(&quot;排序后数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);

    return 0;
}
</code></pre>

<p>PHP和golang版本的这里就不贴了，写完这篇文章单独搞一个github的repo来存放。</p>

<h2 id="插入排序-insertion-sorting">插入排序(insertion sorting)</h2>

<p>这个就像玩扑克抓牌一样，以下是步骤：</p>

<ol>
<li>抓出一张牌，放在左手</li>
<li>再抓出一张牌，从老牌的第一张开始扫描，如果新牌小于老牌，老牌往后移动一位，新牌替换老牌的位置</li>
<li>在上面的扫描过程中，如果新牌大于老牌，则把新牌放在老牌下一位</li>
<li>重复以上步骤</li>
</ol>

<p>来看代码：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

void insertion_sort(int a[], int n)
{
    int i, j, get;

    for (i = 1; i &lt; n; i++) {
        get = a[i];
        j = i - 1;
        while (j &gt;= 0 &amp;&amp; get &lt; a[j]) {
            if (get &lt; a[j]) {
                a[j+1] = a[j];
                j--;
            }
        }
        a[j+1] = get;
    }
}

int main()
{
    int a[] = {2, 3, 8, 1, 5, 7};
    int n = sizeof(a) / sizeof(int);
    int i;

    puts(&quot;原始数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);
    printf(&quot;数组长度: %d\t&quot;, n);

    insertion_sort(a, n);

    puts(&quot;排序后数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);

    return 0;
}
</code></pre>

<p>这个排序貌似比较难理解一些，我再详细的解释一下。</p>

<p>还是把这种排序类比成抓扑克牌。</p>

<ol>
<li>假设手里有一把牌($n$张），我们一般不会去移动第一张牌吧，所以从第二张牌开始，后面的每一张都需要被抓一下，所以外层循环是$n-1$。</li>
<li>第一次以第一张作为基准，取第二张牌，所以内层循环从1开始而不是0。</li>
<li>$get$这个变量是为了暂存取出牌的值</li>
<li>有一个很重要的前提<strong>位于新取出的位置之前的所有牌都是已经排好序的</strong>。所以我们拿新牌去和前面所有已经排序的牌做比较。假设$get = a[i]$，那么如果$a[i-1] &gt; a[i]$，就需要让$a[i-1]$向后移动一位，也就是$a[i] = a[i-1]$，这就是需要$get$这个变量来暂存$a[i]$的原因了。如果前面若干位都大于$get$，那就一直移动到不大于它的为止。这时就会出现一个空缺，这个空缺就需要$get$来填充了</li>
</ol>

<p>看看前面的代码是不是完美的诠释了这个过程？</p>

<h2 id="二分插入排序">二分插入排序</h2>

<p>二分插入排序本质上和（直接）插入排序是一样的，只是在寻找$a[i]$时采用了二分查找法，二分查找发具体算法如下：</p>

<ol>
<li>给定的已排序的序列$b$，长度为$n$，$left$和$right$分别是它的起点和终点，即$left=0;right=n-1$，中间位置$mid=\frac{left+right}{2}$,给定的值$k$。</li>
<li>首先拿序列$b$的中间值和$k$做比较，有以下两种情况:

<ul>
<li>$k &gt; b[mid]$，则$k$的下标位于$b$的后半部分，$left = mid + 1$</li>
<li>$k &lt; b[mid]$，则$k$的下标位于$b$的前半部分，$right = mid - 1$</li>
</ul></li>
<li>如果$left &gt; right$，则查找失败</li>
</ol>

<p>在我们插值的场景中当然是查找失败的，但这却是退出whilex循环的条件，也就是在while循环退出时,$left = right + 1$，而$b[left]$是第一个大于$k$的数。这时就要把$[left, i-1]$位置的所有元素都向后移动一位，然后把$a[left] = k$。好了，这样整个算法就很清晰了。上C代码：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

void binary_sort(int a[], int n)
{
    int i, j, right, left, get;

    for (i = 1; i &lt; n; i++) {
        left = 0;
        right = i - 1;
        get = a[i];

        while (left &lt;= right) {
            int mid = (left + right) / 2;
            if (a[mid] &gt; get) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        for (j = i - 1; j &gt;= left; j--) {
            a[j+1] = a[j];
        }

        a[left] = get;
    }
}

int main()
{
    int a[] = {2, 3, 8, 1, 5, 7};
    int n = sizeof(a) / sizeof(int);
    int i;

    puts(&quot;原始数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);
    printf(&quot;数组长度: %d\t&quot;, n);

    binary_sort(a, n);

    puts(&quot;排序后数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);

    return 0;
}
</code></pre>

<p>有了前面铺垫的描述，这代码写下来就是顺理成章啊。</p>

<h2 id="希尔排序-shell-sorting">希尔排序（shell sorting)</h2>

<p>上面都是很直观的排序方法，下面介绍的几种就没那么直观了。首先是希尔排序。</p>

<p>希尔排序本质上还是插入排序的一种推广，它基于以下两条事实：</p>

<ol>
<li>插入排序在对<strong>几乎已经排好序的数据</strong>操作时，效率高，即可以达到<strong>线性排序</strong>的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序<strong>每次只能将数据移动一位</strong></li>
</ol>

<p>既然知道了插入排序的强项和弱项，就能更好的应用它以提升排序效率了。首先就是要将一个无序的数据构造成<strong>更有序</strong>的状态，也就是前面说的<strong>几乎已经排好序的数据</strong>。</p>

<p>首先把$n$个数分成$2$队，两队中各有$m$个元素。每个元素在本队中的位置和别的队中同样位置的元素构成一组。这样会产生类似$[A_1, B_1], [A_2, B_2],[A_3, B_3], [A_4, B_4]$这样的数据。然后把每组中的两个数据分别排序，按照<strong>递归</strong>的分组策略继续重新分组，把每组中的数据分别排序，最终间隔越来越小，变成1时也就完成了排序。</p>

<p>至于分组策略，一般的实现是从$m = n / 2$开始，持续$m = m / 2$最终$m=1$了。</p>

<p>然后每个组排序，也就有$m$个组。</p>

<p>每组中，按间隔为$m$做插入排序。</p>

<p>不断迭代到$m=1$就完成了排序。</p>

<p>下面是C代码：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

void shell_sort(int a[], int n)
{
    int m, i, j;

    for (m = n / 2; m &gt; 0; m /= 2) {
        printf(&quot;m: %d\n&quot;, m);

        for (i = 0; i &lt; m; i++) {
            for (j = i + m; j &lt; n; j += m) {
                if (a[j] &lt; a[j-m]) {
                    int get = a[j];
                    int k = j - m;
                    while (k &gt;= 0 &amp;&amp; a[k] &gt; get) {
                        a[k+m] = a[k];
                        k -= m;
                    }
                    a[k+m] = get;
                }
            }
        }
    }
}

int main()
{
    int a[] = {2, 3, 8, 1, 5, 7};
    int n = sizeof(a) / sizeof(int);
    int i;

    puts(&quot;原始数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);
    printf(&quot;数组长度: %d\t&quot;, n);

    shell_sort(a, n);

    puts(&quot;排序后数组: &quot;);
    for (i = 0; i &lt; n; i++) {
        printf(&quot;%d\t&quot;, a[i]);
    }
    puts(&quot;&quot;);

    return 0;
}
</code></pre>

<p>这个虽然说了很明白，但总还是不太好理解，如果能把直接插入排序理解成$m=1$的希尔排序的特殊情况就好理解一些了。</p>

                </div>


                <aside>
                    <div class="section"><a href="http://lovelock.coding.me/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="tag">排序算法</a> <a href="http://lovelock.coding.me/tags/%E5%9F%BA%E7%A1%80/" class="tag">基础</a> </div>

                    <div class="section share">
                        <a href="http://v.t.sina.com.cn/share/share.php?src=bm&url=http%3a%2f%2flovelock.coding.me%2falgo%2fsorting-algorithms%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%20%3c%e4%b8%80%3e" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-weibo"></i></a>
                    </div>

                    
                    <div class="section">
                        
                        <div class="ds-thread" data-thread-key="/algo/sorting-algorithms/" data-title="排序算法 &lt;一&gt;" data-url="http://lovelock.coding.me/algo/sorting-algorithms/"></div>
                        

                        
                        <script type="text/javascript">
                            var duoshuoQuery = {short_name:"UnixAgain"};
                        (function() {
                            var ds = document.createElement('script');
                            ds.type = 'text/javascript';ds.async = true;
                            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                            ds.charset = 'UTF-8';
                            (document.getElementsByTagName('head')[0]
                             || document.getElementsByTagName('body')[0]).appendChild(ds);
                        })();
                        </script>
                    </div>
                    
                    
                </aside>

            </article>

        </div>
        <div class="col-md-4">
            
<aside class="site">

  <div class="panel panel-primary">
    <div class="panel-heading">
      <div class="panel-title">
        <span class="fa fa-clock-o"></span><h4>最近文章</h4>
      </div>
    
    </div>
    <div class="list-group">
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/mysql/show-content-length-of-database/" >查看MySQL数据库大小</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/http/slim-put-with-postman/" >Slim 获取Postman发送的PUT请求的body</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/algo/sorting-algorithms/" >排序算法 &lt;一&gt;</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/linux/config-of-nginx-load-balancing/" >Nginx负载均衡分配策略详解</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/linux/proxy-and-reverse-proxy/" >认识正向代理和反向代理</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/linux/set-docker-image-mirror/" >为Docker配置国内加速镜像</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/php/about-php-interface/" >关于PHP接口特性的一个发现</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/php/internals/create-variables/" >创建变量(PHP5.x扩展)</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/php/internals/a-function-without-arguments/" >没有参数的函数（区别于类的方法）</a>
      </div>
      
      <div class="list-group-item">
      <i class="fa fa-file-o" aria-hidden="true"></i> <a href="http://lovelock.coding.me/bigdata/cleanup-dirty-data-in-hdfs/" >清理HDFS的脏数据</a>
      </div>
      
    </div>
  </div>

  
    
    
  
    
    
  

</aside>


        </div>
    </div>

</div>

      </div>
    </div>

    <footer class="site">
      <div class="container">
        <p>(c) 2013-2016 Frost Wong. All rights reserved.</p>
        <p>Powered by <a href="http://gohugo.io" target="_blank" rel="nofollow">Hugo</a>, Theme <a href="https://github.com/lovelock/hugo_theme_tech" target="_blank" rel="nofollow">tech</a> designed by <a href="http://lovelock.coding.me" target="_blank" rel="nofollow">Frost Wong</a></p>
      </div>
    </footer>

    <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
    <script src="//cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdn.bootcss.com/highlight.js/9.7.0/highlight.min.js"></script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$', '$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\[','\]']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: { equationNumbers: { autoNumber: "AMS" },
                 extensions: ["AMSmath.js", "AMSsymbols.js"] }
          }
        });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        // Fix <code> tags after MathJax finishes running. This is a
        // hack to overcome a shortcoming of Markdown. Discussion at
        // https://github.com/mojombo/jekyll/issues/199
        var all = MathJax.Hub.getAllJax(), i;
        for(i = 0; i &lt; all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    </script>
    <script>hljs.initHighlightingOnLoad();</script>

    

  </body>
</html>

