<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Me &amp; Web</title>
    <link>http://unixera.com/</link>
    <description>Recent content on Me &amp; Web</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>frostwong@gmail.com (Frost Wong)</managingEditor>
    <webMaster>frostwong@gmail.com (Frost Wong)</webMaster>
    <copyright>(c) 2013-2016 Frost Wong. All rights reserved.</copyright>
    <lastBuildDate>Sat, 03 Sep 2016 17:20:45 +0800</lastBuildDate>
    <atom:link href="http://unixera.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DeepinLinux体验报告</title>
      <link>http://unixera.com/linux/deepin-linux-experience/</link>
      <pubDate>Sat, 03 Sep 2016 17:20:45 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/linux/deepin-linux-experience/</guid>
      <description>

&lt;h2 id=&#34;为什么要写这篇文章&#34;&gt;为什么要写这篇文章&lt;/h2&gt;

&lt;p&gt;今天忽然看到知乎上的通知，发现两年前写的一篇答案现在还有人在关注和评论&lt;a href=&#34;https://www.zhihu.com/question/19694358/answer/26227403?group_id=748099576984006656#comment-158674705&#34;&gt;有人用国产的deepin吗？和其它Linux版本相比，有什么优点和不足呢？&amp;ndash;郁蓝的答案&lt;/a&gt;。也是无意间看到了有人让我再更新一下体验的要求（其实这个评论是很早之前的了，只不过今天刚注意到）。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814221945.png&#34; alt=&#34;知乎答案评论截图&#34; /&gt;
虽然我也不是什么大神，但从我个人的感情来说，我还是很希望深度能做的更好的，所以就花了几个小时真的感受了一下。下面是我认为还比较中肯的看法。&lt;/p&gt;

&lt;h2 id=&#34;体验&#34;&gt;体验&lt;/h2&gt;

&lt;h3 id=&#34;1-官方网站-https-www-deepin-org&#34;&gt;1. &lt;a href=&#34;https://www.deepin.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&#34;华而不实&#34;&gt;华而不实&lt;/h4&gt;

&lt;p&gt;不得不说，这个网站初看上去还是挺好看的，但实际一看就是一个展示页，而且有相当的&lt;strong&gt;应付了事&lt;/strong&gt;的成分。那个国际排名也多少有点忽悠的感觉。。。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814225102.png&#34; alt=&#34;深度官网展示&#34; /&gt;
因为对细节的展示很少，文档也是七零八碎，像我这样阅发行版无数的人当然很快就找到了安装方法（其实也没有找，只是按照经验），但对于完全不懂Linux的新手来说，很可能看一下就撤了。&lt;/p&gt;

&lt;h4 id=&#34;功能缺失&#34;&gt;功能缺失&lt;/h4&gt;

&lt;p&gt;即便这样，我觉得很多我关心的信息在网站上都没有展示出来。我是一名软件开发人员，说的更笼统一些是一名上班族，那从一个上班族的角度来看，如果要我从Windows迁移到Deepin OS，我会关注哪些东西？当然是办公软件的使用。这个&lt;strong&gt;办公软件&lt;/strong&gt;是广义上的，包括&lt;strong&gt;QQ,RTX,Office,搜狗输入法，邮件&lt;/strong&gt;等等，这个问题，产品经理肯定想过，因为我用了之后发现确实他们已经解决了，但在页面上并没有展示出来。甚至，我的希望是&lt;strong&gt;在页面上能有一个搜索框，我在安装之前就能知道哪些软件我能用，让我不会产生后顾之忧&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;细节不到位&#34;&gt;细节不到位&lt;/h4&gt;

&lt;p&gt;我甚至点到了社区板块，看了一下更新日志，比如这篇&lt;a href=&#34;http://blog.deepin.org/2016/08/update-record-of-applications-in-deepin-store-2016-08/&#34;&gt;深度商店应用更新记录汇总2016-08&lt;/a&gt;。这样的汇总我实在是不想看，感觉就像是用awk+xargs处理了一下只把应用名打印出来的样子。我看到了两个问题：
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814225410.png&#34; alt=&#34;社区网页展示&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- 没有版本号，**差评**
- 应用名太拥挤，看起来不直观
- 层级不能回退，都实现成这样的控件竟然不能点击，简直不能忍
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我看到右侧其实是又很多这种更新汇总的，我觉得这作为一个正常人是都能看得到的问题，但就是不知道为什么那么久了都还一直这样。这期的我看到下面又评论说到没有版本号的事情，管理员（不知道是不是）说下次会带上。&lt;/p&gt;

&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;

&lt;p&gt;总的感觉就是&lt;strong&gt;华而不实&lt;/strong&gt;，对细节的考虑不到位，简直浪费了程序员们的辛苦劳动。东西再好，展示的窗口都不做好，怎么吸引人呢？我觉得要么就传统一些，做一个像&lt;a href=&#34;https://www.archlinux.org/&#34;&gt;ArchLinux官网&lt;/a&gt;那样的纯展示性网站，引导用户去一个完备的Wiki站点，要么就学一学现在的手机厂商，把现代化的网页做的详细一些，别让用户费了半天劲把页面从最上面拉到最下面了却发现什么也没看明白。&lt;/p&gt;

&lt;h3 id=&#34;1-安装直观感受&#34;&gt;1. 安装直观感受&lt;/h3&gt;

&lt;p&gt;没有LiveCD，差评。
很不理解的一点，我刻好了优盘启动盘准备先在LiveCD里体验一下，看到启动项只有一个&lt;strong&gt;Start installation&lt;/strong&gt;我就懵逼了。。。这是跟国产的流氓软件学的，不让尝，先买了再说么？&lt;/p&gt;

&lt;h3 id=&#34;2-缺点&#34;&gt;2. 缺点&lt;/h3&gt;

&lt;p&gt;整个安装界面就有些搞不清楚。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有保留像Ubuntu那样可以&lt;strong&gt;对用户透明的和其他系统共存&lt;/strong&gt;的功能。（貌似最近的这版从基于Ubuntu迁移到了Debian Sid，这样就可以解释了，关于迁移的事情后面会说）&lt;/li&gt;
&lt;li&gt;对高清屏的支持不好，这在上面的截图里都已经可以看到了，我的电脑是15寸1080P屏幕，显示的字体太小，伤眼睛&lt;/li&gt;
&lt;li&gt;选择完语言之后就没得回去了，只能往后，不能往前，这有点蛋疼&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好在安装过程很顺利，也很快。这点很赞。&lt;/p&gt;

&lt;h3 id=&#34;3-亮点&#34;&gt;3. 亮点&lt;/h3&gt;

&lt;p&gt;吐槽完了也得有点亮点吧，也不旺我把Ubuntu分区都干掉装这个啊。界面风格没啥好说的，还提供了三种模式
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814180441.png&#34; alt=&#34;默认Dock模式&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814230948.png&#34; alt=&#34;Windows Dock模式1&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814231109.png&#34; alt=&#34;Windows Dock模式2&#34; /&gt;
看完上面三张图，你有什么感受？对，没有自己的灵魂，学谁都没学像。学苹果却没有Magic动画，学Windows又没有开始菜单。而且控制面板放在最右边是什么鬼？是为了适应触摸屏？模仿Windows8的交互？看吧，Windows10已经回归了，我估计这个控制面板也要改成传统模式了。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814231725.png&#34; alt=&#34;控制面板&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说了这些发现还是吐槽，真正的亮点在终端。貌似是修改版的Quake，但我可没有在Quake里面找到过这个功能，简直贴心。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814232511.png&#34; alt=&#34;SSH管理功能&#34; /&gt;
试了一下，简直弱鸡啊，也仅仅是个管理，连私钥都不支持。好吧，完成度不高，忍了。&lt;/p&gt;

&lt;p&gt;应用商店的资源还是挺丰富的，常用的差不多都有——其实本来Gnome也都有了。重点在于深度为用户提供了几乎0成本使用QQ的机会，这点很重要，一直以来对中国用户来说，Linux最大的痛点不就是没有QQ么？
其他软件也是开箱即用，完整度还可以，但完成度有待提高。&lt;/p&gt;

&lt;h3 id=&#34;4-混乱&#34;&gt;4. 混乱&lt;/h3&gt;

&lt;p&gt;整个一下午用下来最大的感受就是&lt;strong&gt;混乱&lt;/strong&gt;，看起来深度桌面更像是基于Gnome的，也带了不少Gnome系的应用，但它其实又在Gnome的基础上加上了自己的想法，让体验变得更加不统一了。比如应用打开首选项的方式和图标都不统一，有些按钮的位置那是真隐晦，谁能看出来那是按钮我服谁。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814235541.png&#34; alt=&#34;界面高度不统一&#34; /&gt;
至于其中的某些Qt的应用带了的体验不一致这里就不说了，目前也没什么好的解决办法。&lt;/p&gt;

&lt;h3 id=&#34;5-期望&#34;&gt;5. 期望&lt;/h3&gt;

&lt;p&gt;总的来说，功能做的还是不错的，因为加入了Windows上常用的软件，使得它基本上算是一个开箱即用的操作系统。尤其是搜狗输入法的加成，让它对普通用户的友好程度大增。我搜了一下，软件源里面是包含Jetbrains家的应用的。只不过版本比较老了而已。看起来也没有对其进行什么修改，不知道是什么耽搁了它和上游的同步。现在这个Quake的SSH管理功能太弱鸡，如果可以，我希望能把Windows上的XShell引进来，毕竟Mac和Linux上都没有一款这么好用的终端。&lt;/p&gt;

&lt;p&gt;总之，深度的这款操作系统还是很能解决中国人用Linux的痛点的，这些痛点真的不是加个天气软件和农历日历就能解决的。很多使用习惯的问题需要去引导和克服。有人说，有这闲工夫通过各种技术手段让Windows上的软件跑在Linux上还不如大力发展Linux的原生应用，简直是Naive，如果原生的这么好做，也就不会有CrossOver这样的收费软件了。这毕竟是软件提供商的问题，他们不重视，作为用户也只能想别的办法了，起码在目前看来，这种方式是最行之有效又一针见血的。&lt;/p&gt;

&lt;p&gt;我想提的建议是，产品经理要是没什么大问题的话就换了吧，现在的真心不称职。包括网站的和桌面端的，抄别人的东西都抄不到精髓，那只能说自己都不知道想抄什么。那壁纸怎么那么像一加天气的背景呢？看我还是个耿直的boy，一加的ROM不行，确实是开发不给力，而Deepin做不好，产品要负大部分责任。&lt;/p&gt;

&lt;p&gt;感谢深度在Linux国产化的进程中的突出贡献。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>给Java新手看的mvn指南</title>
      <link>http://unixera.com/java/mvn-tutorial-for-novice/</link>
      <pubDate>Sun, 28 Aug 2016 14:29:16 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/java/mvn-tutorial-for-novice/</guid>
      <description>

&lt;h2 id=&#34;官方定义&#34;&gt;官方定义&lt;/h2&gt;

&lt;p&gt;Maven是基于项目对象模型，可以通过一小段描述信息来管理项目的构建、报告和文档的软件管理工具。&lt;/p&gt;

&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;Maven的使用过程中最经常用到的就是依赖管理了，一个依赖也就是一个包，是包含了几个属性的
- &lt;code&gt;groupId&lt;/code&gt; 通常是公司域名的反写加上项目名，比如&lt;code&gt;com.unixera.mvndemo&lt;/code&gt;
- &lt;code&gt;artifactId&lt;/code&gt; 模块名，比如&lt;code&gt;project1&lt;/code&gt;
- &lt;code&gt;version&lt;/code&gt; 版本号，经常见到的是形如&lt;code&gt;1.0.0-SNAPSHOT&lt;/code&gt;这种，即快照版本，还有&lt;code&gt;RELEASE&lt;/code&gt;等。&lt;/p&gt;

&lt;h2 id=&#34;规定&#34;&gt;规定&lt;/h2&gt;

&lt;p&gt;它规定的目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-src 
 -main
  -java
   -packagename
 -test
  -java
   -packagename
 -resource
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基础命令&#34;&gt;基础命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mvn compile&lt;/code&gt; 编译项目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn test&lt;/code&gt; 测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn package&lt;/code&gt; 打包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn clean&lt;/code&gt; 删除已经生成的测试报告和字节码文件，其实就是删除target文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn install&lt;/code&gt; 安装jar包到本地目录中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面这5个过程如果执行后面的，前面的也会自动执行。也就是说后面的命令是依赖前面的命令的。&lt;/p&gt;

&lt;h2 id=&#34;经常遇到的问题&#34;&gt;经常遇到的问题&lt;/h2&gt;

&lt;h3 id=&#34;1-间接依赖&#34;&gt;1. 间接依赖&lt;/h3&gt;

&lt;p&gt;A依赖B，B依赖C，那么A就间接的依赖了C，如果要显式的声明A不依赖C，可以在A的pom.xml中加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
&amp;lt;dependecy&amp;gt;
	&amp;lt;groupId&amp;gt;BgroupId&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;BartifactId&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
	&amp;lt;exclusions&amp;gt;
		&amp;lt;exclusion&amp;gt;
			&amp;lt;groupId&amp;gt;CgroupId&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;CartifactId&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
		&amp;lt;/exclusion&amp;gt;
	&amp;lt;/exclusions&amp;gt;
&amp;lt;/dependecy&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-如何添加依赖&#34;&gt;2. 如何添加依赖&lt;/h3&gt;

&lt;p&gt;比如项目要使用servlet，那就去&lt;a href=&#34;http://search.maven.org/&#34;&gt;全球中央仓库&lt;/a&gt;查找包名和相应的版本号,如图所示&lt;img src=&#34;http://ww4.sinaimg.cn/large/7853084cjw1f79btj2nb8j20fl0f9q4b.jpg&#34; alt=&#34;&#34; /&gt;。从中复制Apache Maven下面的一段XML粘贴到相应的&lt;code&gt;&amp;lt;dependencies&amp;gt;&amp;lt;/dependencies&amp;gt;&lt;/code&gt;中即可。&lt;/p&gt;

&lt;h3 id=&#34;3-变量的使用&#34;&gt;3. 变量的使用&lt;/h3&gt;

&lt;p&gt;有时在一个pom.xml文件中会看到有&lt;code&gt;${project.version}&lt;/code&gt;这种写法，那一看就是一个引用，这个东西是在&lt;code&gt;&amp;lt;properties&amp;gt;&amp;lt;/properties&amp;gt;&lt;/code&gt;中定义的，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties&amp;gt;
    &amp;lt;maven.compile.source&amp;gt;1.5&amp;lt;/maven.compile.source&amp;gt;
    &amp;lt;maven.compile.target&amp;gt;1.5&amp;lt;/maven.compile.target&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样定义了之后在后面就可以用&lt;code&gt;${maven.compile.source}&lt;/code&gt;来引用了。&lt;/p&gt;

&lt;h3 id=&#34;4-一个项目下多个模块重复依赖一个包&#34;&gt;4. 一个项目下多个模块重复依赖一个包&lt;/h3&gt;

&lt;p&gt;下面着重说一下如何利用Maven的继承关系简化项目的POM配置。&lt;/p&gt;

&lt;h4 id=&#34;在项目的根目录下创建pom-xml&#34;&gt;在项目的根目录下创建pom.xml&lt;/h4&gt;

&lt;p&gt;还以上面的项目名为例，比如root目录是project,则在project目录里创建pom.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;groupId&amp;gt;com.unixera&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;root&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
	
	&amp;lt;properties&amp;gt;
	    &amp;lt;project.version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/project.version&amp;gt;
	    &amp;lt;junit.version&amp;gt;4.10&amp;lt;/junit.version&amp;gt;
	    &amp;lt;jmock.version&amp;gt;2.8.2&amp;lt;/jmock.version&amp;gt;
	&amp;lt;/properties&amp;gt;
	
	&amp;lt;dependencies&amp;gt;
	    &amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.jmock&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jmock&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${jmock.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就声明了该项目需要依赖junit，那么里面的子项目就用&lt;code&gt;mvn archetype:generate&lt;/code&gt;来交互式的生成，比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Choose org.apache.maven.archetypes:maven-archetype-quickstart version:
1: 1.0-alpha-1
2: 1.0-alpha-2
3: 1.0-alpha-3
4: 1.0-alpha-4
5: 1.0
6: 1.1
Choose a number: 6: 6
Define value for property &#39;groupId&#39;: : com.unixera.mvndemo
Define value for property &#39;artifactId&#39;: : project1
Define value for property &#39;version&#39;:  1.0-SNAPSHOT: :
Define value for property &#39;package&#39;:  com.unixera.mvndemo: :
Confirm properties configuration:
groupId: com.unixera.mvndemo
artifactId: project1
version: 1.0-SNAPSHOT
package: com.unixera.mvndemo
 Y: :
[INFO] ----------------------------------------------------------------------------
[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.1
[INFO] ----------------------------------------------------------------------------
[INFO] Parameter: basedir, Value: /Users/frost/IdeaProjects
[INFO] Parameter: package, Value: com.unixera.mvndemo
[INFO] Parameter: groupId, Value: com.unixera.mvndemo
[INFO] Parameter: artifactId, Value: project1
[INFO] Parameter: packageName, Value: com.unixera.mvndemo
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] project created from Old (1.x) Archetype in dir: /Users/frost/IdeaProjects/project1
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 35.492 s
[INFO] Finished at: 2016-08-28T14:16:28+08:00
[INFO] Final Memory: 13M/201M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;project&lt;/code&gt;目录，打开&lt;code&gt;pom.xml&lt;/code&gt;，可以看到mvn生成的项目已经默认依赖了junit，那我们来修改一下让它依赖parent所定义的junit。
首先加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.unixera.mvdemo&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;root&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以把junit的依赖放心的删掉了，因为它已经认了root做parent，parent的依赖就是它的依赖了。&lt;br /&gt;
那如果parent的某些依赖它并不需要呢？可以在子项目中添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.unixera.mvndemo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;root&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.jmock&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;jmock&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子项目就不依赖jmock模块了。&lt;/p&gt;

&lt;p&gt;当然mvn的使用远远不止这些，这里记录一些目前使用到的，后面如果还继续回写Java的话会再更新一下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用ssh-config提升你的生产力</title>
      <link>http://unixera.com/mac/use-ssh-config-to-tune-your-productivity-up/</link>
      <pubDate>Tue, 09 Aug 2016 14:57:11 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/mac/use-ssh-config-to-tune-your-productivity-up/</guid>
      <description>

&lt;p&gt;我们做服务端开发的，每天最烦心的事情可能就是登陆各种服务器了。在Windows上还好，有SecureCRT还有XShell这种很强大的工具可以用，但在Mac下面选择就很少了。SecureCRT我个人感觉远远不如Windows下的稳定，而渲染效果我当然还是最喜欢iTerm了。其实并没有用到它的很强大的那些功能，比如窗口分割、全局查找等等，最能打动我的其实是智能复制粘贴。不多说了，下面说一下怎样用ssh的config文件来记住登录账户。&lt;/p&gt;

&lt;h2 id=&#34;常规的解决方案&#34;&gt;常规的解决方案&lt;/h2&gt;

&lt;p&gt;我们最习惯用已知的知识来解决新问题。所以当然你会在.bashrc中添加一条&lt;code&gt;alias dev=&#39;ssh root@10.69.41.41&#39;&lt;/code&gt;这种命令了——注意，这个指令在多数环境中其实是不适用的，因为还面临通道机——最让开发头痛的东西。&lt;/p&gt;

&lt;p&gt;所以让我们来发掘一下ssh的强大威力。&lt;/p&gt;

&lt;h2 id=&#34;用ssh-config提高效率&#34;&gt;用ssh config提高效率&lt;/h2&gt;

&lt;h3 id=&#34;可以直连的机器&#34;&gt;可以直连的机器&lt;/h3&gt;

&lt;p&gt;如果可以直连一台机器，比如我的192.168.1.104虚拟机，那就可以在&lt;code&gt;.ssh/config&lt;/code&gt;中添加一段记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host debian
	Hostname 192.168.1.104
	Port 22
	User frost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需重启，现在执行&lt;code&gt;ssh debian&lt;/code&gt;就可以连接debian机器了。&lt;br /&gt;
那么问题来了，通常来说，Linux环境中是找不到明文存储的密码的，这里也不例外，肯定不会让你把密码直接写在这个配置文件中。要实现重新打开一个标签连接同一台机器不需要重新输密码，有两种方式。&lt;/p&gt;

&lt;h4 id=&#34;1-用key登录&#34;&gt;1. 用key登录&lt;/h4&gt;

&lt;p&gt;具体操作这里不展开，这里只需要把key的路径加在配置文件里即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host debian
	Hostname 192.168.1.104
	IdentityFile ~/.ssh/coolio.example.key
	Port 22
	User frost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。这是最简单直接的方式。&lt;/p&gt;

&lt;h4 id=&#34;2-模拟securecrt的-复制会话-功能&#34;&gt;2. 模拟SecureCRT的『复制会话』功能&lt;/h4&gt;

&lt;p&gt;也就是说，在一个标签登录了一台机器之后，会在本地保存一份该会话的标识文件。当重新连接这个机器时，会使用这个临时文件当做认证，直接登录而无需验证。局限是如果重启了终端，就需要重新输入一次密码。&lt;br /&gt;
要实现这个功能，只需要在&lt;code&gt;.ssh/config&lt;/code&gt;里加入这样一段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能要问了，key那么方便，为什么需要这样呢？这是因为我们认为key已经很安全了，但安全组的同事可能觉得也没那么安全，他们希望我们用安全性更高的静态密码+动态口令的方式登录跳板机，而且跳板机是无法存储任何文件的，无法实现保存key。&lt;/p&gt;

&lt;h3 id=&#34;无法直连的机器&#34;&gt;无法直连的机器&lt;/h3&gt;

&lt;p&gt;前面提到了跳板机，登录到跳板机当然不是目的，还要登录各种各样的机器，如果我要经常登录一台跳板机后的机器，难道要每次都先登录跳板机（虽然不用每次都输入密码）然后再手工跳转到另一台机器？当然不是。这里要引入『本地端口转发』的概念。
说白了就是我们指定一个本地端口，往这个端口发送的所有数据都会通过&lt;strong&gt;跳板机&lt;/strong&gt;被转发到另外一台机器的指定端口。注意两个指定端口不需要是一样的。比如我希望通过本地的2222端口来登录一台开发机的22端口。就需要这样配置一个隧道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host tunnel
	HostName 10.0.0.2
	LocalForward 2222 10.30.43.23:22
	User frost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样执行&lt;code&gt;ssh -f -N tunnel&lt;/code&gt;就会建立这条本地端口转发的隧道。其实还需要一段配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host dev
	HostName 127.0.0.1
	Port 2222
	User root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，看到&lt;code&gt;ssh -f -N tunnel&lt;/code&gt;这条这么长的指令还是不爽，这时就可以用alias来简化输入了。&lt;/p&gt;

&lt;h3 id=&#34;服务器和本地传输文件&#34;&gt;服务器和本地传输文件&lt;/h3&gt;

&lt;p&gt;其实用SecureCRT或者XShell还有一个很重要的原因是二者对lrzsz这个小工具的支持很好，而几乎所有的终端工具都存在各种问题，iTerm2也不例外。虽然也可以有workaround来解决，但毕竟不是原生，不好用。我也纠结了很久，原来Mac上没有相应的工具是因为真的不需要啊。&lt;br /&gt;
现在跟我一起做，比如我们前面已经配了一个可以本地直连的远程机器debian，当需要传输文件的时候只需要在本地命令窗口打开&lt;code&gt;sftp debian&lt;/code&gt;就会打开一个交互的shell。那么不要怕，虽然它有很多命令，但我觉得简单的使用只需要记住4组命令就好了，而且其中3组是原来就会的。&lt;br /&gt;
首先要知道本地和远程的概念，因为你执行了这个命令之后其实已经登陆了了远程机器了，只不过不在bash里面，所以现在你要操作本地的东西时，所有命令都要加上&lt;code&gt;l&lt;/code&gt;也就是local，而远程的就什么都不加了。&lt;br /&gt;
所以记住下面几个命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lpwd&lt;/code&gt; 查看本地机器当前所在目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pwd&lt;/code&gt; 查看远程机器当前所在目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lls&lt;/code&gt; 查看本地机器当前目录下的文件列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; 查看远程机器当前目录下的文件列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lcd dir&lt;/code&gt; 在本地切换到目标目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd dir&lt;/code&gt; 在远程主机上切换到目标目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put filename&lt;/code&gt; 把本地的文件放在远程主机的当前位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get filename&lt;/code&gt; 把远程机器上的目录下载到本地当前位置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这和SecureCRT的实现方式是完全一样的，XShell好封装了一个两栏的文件管理器呢，这样看来XShell真的是业界良心。&lt;/p&gt;

&lt;p&gt;有人可能会说用expect来实现密码自动填充也是极好的。这个问题，见仁见智吧，至少用了一段时间之后我是不喜欢用expect了，最主要的问题在于窗口的自动缩放，就不展开说了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谈谈转基因食物</title>
      <link>http://unixera.com/miscs/talk-about-transgene-foods/</link>
      <pubDate>Sun, 17 Jul 2016 22:53:33 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/miscs/talk-about-transgene-foods/</guid>
      <description>&lt;p&gt;这件事情其实我没有怎么关注过，到超市去买油什么的也是全凭一时冲动，没有固定的品牌和品种。&lt;/p&gt;

&lt;p&gt;因为我是生物专业毕业的，知道的人难免会让我谈谈关于转基因食物的看法，因为我并不了解社会上对这件事的主流看法是怎样的，所以在谈这个问题时往往不太敢太明显的表达自己的观点，而会模棱两可的说我认为转基因是无害的，而具体是否是这样，还需要科学家们去证实。&lt;/p&gt;

&lt;p&gt;我觉得任何一个学过高中生物课的人都应该能明白这个道理。我们吃的食物在体内是经过消化和分解过程的。最终吸收到体内的不过是一个个的生物大分子片段，这些片段包括氨基酸，也就是蛋白质的组成结构，当然也有（脱氧）核糖核酸，注意，我说的是片段，因为它们也仅仅是片段，它们的作用是为我们提供营养物质，而不是改变我们身体的性状。&lt;/p&gt;

&lt;p&gt;之所以很多人一提到转基因就害怕，可能是社会上某些公知人士的大肆渲染，毕竟因为自己不懂，对那些认为自己很懂又很愿意宣传，同时很有影响力的人当然大多数人会选择深信不疑。这种盲从很可怕。&lt;/p&gt;

&lt;p&gt;看过我文章的读者可能知道我喜欢用最贴近生活的例子来阐述一件事情。那对于转基因这件事，我还是有个例子可以说。&lt;/p&gt;

&lt;p&gt;转基因可以分为自然转基因和人工转基因。大多数人害怕的其实是『人工转基因』。想理解人工转基因，那就得先知道什么是自然转基因。其实自然转基因在生活中处处可见，比如你家的小狗狗生了一群小小狗狗，小小狗狗的爸爸妈妈都是黑色的，但有可能这群小小狗狗里有一只身上出现了白色的斑点，这就有可能是基因突变引起的。我说有可能是因为关于狗的遗传特性我并没有具体研究，不知道毛色是显性还是隐形性状。咱们单说这个毛色的突变，从基因的层面上说就是有可能小小狗狗的某一条染色体上的F变成了F1,然后它翻译、转码生成的蛋白质就变成了白色。当这只小小狗狗再生小宝宝时，这种白色的性状就有可能保留了下来。假设，在这只小狗之前世界上没有带白色斑点的狗，那么严格的说，我们甚至可以说基因突变『产生』了一种新的性状。&lt;/p&gt;

&lt;p&gt;其实，基因突变就是一种自然转基因的类型。我说它是一种类型，那肯定就还有别的类型，那就是杂交了。别以为只有在人类的干预下才会有杂交的出现，其实自然界中这种现象相当普遍。一般来说生物之间是有自然隔离的，但大自然就是这么神奇，万一两种生物的染色体条数一样多，再加上其他因素也匹配，那么两种生物就有可能杂交而产生一种新的物种。当然我印象中的杂交产物就是骡子了，但骡子是没有繁殖能力的，并不能算是新的物种。&lt;/p&gt;

&lt;p&gt;那对应基因突变和杂交，人工转基因究竟干了什么呢？&lt;/p&gt;

&lt;p&gt;对狭义的转基因（排除杂交）而言，转基因就是把一个物种的DNA上某些片段重新编码成新的序列，从而产生新的性状。（这不是教科书上的定义，可能并不准确，只是我的理解）而产生这种重新编码的方法也有多种，有可能是从其他物种的DNA上截取一截粘贴上去，也可能是直接人工重新排序一段编码，还有最初的用宇宙射线什么的引发基因突变等等，当年学的什么密码子啥玩意儿的都忘得差不多了，只需要知道这些技术现在已经工业化了就对了，根本不是问题。&lt;/p&gt;

&lt;p&gt;想想有点可笑，外面都说我们中国人什么都吃，但到了转基因这里却变得异常谨慎了。&lt;/p&gt;

&lt;p&gt;那么，我就想问了，黑色狗是狗，带斑点的狗还是狗吗？『正常』的大豆是大豆，转基因的大豆就不是大豆了？你吃的转基因豆油大部分只是脂肪而已，到了肚子里是还要经过消化的，它只不过变成了我们需要的各种氨基酸等，并没有让我们的基因重排，并不会改变我们的性状。&lt;/p&gt;

&lt;p&gt;今天还看到微博上自称『央视新闻』的媒体说某些主要成分是『氯化钠』的假冒食盐已经流向市场，长期食用氯化钠可引起头晕等等症状，说的头头是道，我看了好多遍到底说的是不是氯化钠，最后确定还真是，而且这个微博账号确实是官方的。这么说那还不如说『某某生成的劣质水，主要成分是一氧化二氢，大量食用会引起膀胱胀痛』。&lt;/p&gt;

&lt;p&gt;如果你觉得民智没有开启，那么就请尽自己的一份力量多解释一下；如果他们不愿意听，你可以解释给下一个人听，没有必要变得像他们一样，网络上全是乌烟瘴气的对骂，没有意义，而且会让自己显得和他们一样，只是喷子，更没有人愿意听你的真相了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——扩展的骨架</title>
      <link>http://unixera.com/php/internals/create-skeleton-of-extension/</link>
      <pubDate>Sat, 09 Apr 2016 22:04:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/internals/create-skeleton-of-extension/</guid>
      <description>

&lt;p&gt;前面啰嗦了这么多读者都要没有兴趣了。从现在起要真正开始PHP扩展开发阶段了。&lt;/p&gt;

&lt;p&gt;首先来生成扩展的骨架。所谓骨架就是一个扩展需要的基本文件了。&lt;/p&gt;

&lt;h2 id=&#34;获取php源码&#34;&gt;获取PHP源码&lt;/h2&gt;

&lt;p&gt;截至目前，PHP最新源码是7.0.5。&lt;a href=&#34;http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  projects wget http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror -O php705.tar.bz2
--2016-04-09 10:18:39--  http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror
Resolving cn2.php.net (cn2.php.net)... 202.108.35.194, 202.108.35.235, 202.108.35.237, ...
Connecting to cn2.php.net (cn2.php.net)|202.108.35.194|:80... connected.
HTTP request sent, awaiting response... 302 Found
Location: http://cn2.php.net/distributions/php-7.0.5.tar.bz2 [following]
--2016-04-09 10:18:39--  http://cn2.php.net/distributions/php-7.0.5.tar.bz2
Reusing existing connection to cn2.php.net:80.
HTTP request sent, awaiting response... 200 OK
Length: 14086522 (13M) [application/octet-stream]
Saving to: ‘php705.tar.bz2’

php705.tar.bz2                             100%[=======================================================================================&amp;gt;]  13.43M  4.49MB/s    in 3.0s

2016-04-09 10:18:42 (4.49 MB/s) - ‘php705.tar.bz2’ saved [14086522/14086522]

➜  projects md5sum php705.tar.bz2
b15e6836babcbf0aa446678ee38f896b  php705.tar.bz2
➜  projects echo b15e6836babcbf0aa446678ee38f896b
b15e6836babcbf0aa446678ee38f896b
➜  projects tar xjf php705.tar.bz2
➜  projects cd php-7.0.5/ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于来到了正题了。我现在也终于明白鸟哥为啥费劲写个生成Yaf最小化应用的脚本了，就是从写扩展的经历中得来的，既然可以帮用户做的更多，那就帮一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext ./ext_skel --extname=hylog
Creating directory hylog
Creating basic files: config.m4 config.w32 .gitignore hylog.c php_hylog.h CREDITS EXPERIMENTAL tests/001.phpt hylog.php [done].

To use your new extension, you will have to execute the following steps:

1.  $ cd ..
2.  $ vi ext/hylog/config.m4
3.  $ ./buildconf
4.  $ ./configure --[with|enable]-hylog
5.  $ make
6.  $ ./sapi/cli/php -f ext/hylog/hylog.php
7.  $ vi ext/hylog/hylog.c
8.  $ make

Repeat steps 3-6 until you are satisfied with ext/hylog/config.m4 and
step 6 confirms that your module is compiled into PHP. Then, start writing
code and repeat the last two steps as often as necessary.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，&lt;code&gt;ext_skel&lt;/code&gt;就帮我们生成了一个名为&lt;code&gt;hylog&lt;/code&gt;的扩展框架。&lt;/p&gt;

&lt;p&gt;下面要介绍一下安装扩展的两种方式了，一种是直接编译进PHP，一种是接下来我们要讨论的这种，即动态加载的扩展。&lt;/p&gt;

&lt;p&gt;什么是直接编译进PHP呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext cd hylog
➜  hylog ls
config.m4  config.w32  CREDITS  EXPERIMENTAL  hylog.c  hylog.php  php_hylog.h  tests
➜  hylog vim config.m4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会看到这样的几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl If your extension references something external, use with:

dnl PHP_ARG_WITH(hylog, for hylog support,
dnl Make sure that the comment is aligned:
dnl [  --with-hylog             Include hylog support])

dnl Otherwise use enable:

dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;dnl&lt;/code&gt;是注释，主要看&lt;code&gt;--with-hylog&lt;/code&gt;和&lt;code&gt;--enable-hylog&lt;/code&gt;。假定你来看本文，你一定自己编译过PHP了，如果没有，那先去整一遍再回来看吧：）
是这样的，我们在编译PHP的时候经常会碰到类似这种&lt;code&gt;--with[out]-blah=/path/to/foo&lt;/code&gt;或者&lt;code&gt;--enable-blah&lt;/code&gt;或者&lt;code&gt;--disable-blah&lt;/code&gt;的选项吧。其实对编写扩展的我们来说，这两种都是可行的，并没有本质上的区别，只是一般用&lt;code&gt;--with&lt;/code&gt;会带个路径，告诉PHP这个扩展依赖的外部库的路径，而&lt;code&gt;--enable&lt;/code&gt;则表示该扩展是独立的，或者依赖的库在默认的搜索路径内。&lt;/p&gt;

&lt;p&gt;那和我们说的两种安装方式有什么关系呢？不如我们就来真的安装一下看看效果吧。&lt;/p&gt;

&lt;p&gt;看上面的注释，我们知道了需要把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
[  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于是喜欢用&lt;code&gt;--enable&lt;/code&gt;还是喜欢用&lt;code&gt;--with&lt;/code&gt;看个人喜好了，因为本例中并没有用到外部依赖，所以用&lt;code&gt;--enable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;提醒一下，改完之后最好把当前的这个状态保存下来——创建一个git工作目录就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git init
Initialized empty Git repository in /home/frost/projects/php-7.0.5/ext/hylog/.git/
➜  hylog git:(master) ✗ gst
On branch master

Initial commit

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	.gitignore
	CREDITS
	EXPERIMENTAL
	config.m4
	config.w32
	hylog.c
	hylog.php
	php_hylog.h
	tests/

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
➜  hylog git:(master) ✗ ga .
➜  hylog git:(master) ✗ gc -m &#39;init hylog&#39;
[master (root-commit) 58e5e4a] init hylog
 Committer: frost &amp;lt;frost@debian.unixera.com&amp;gt;
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 9 files changed, 409 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 CREDITS
 create mode 100644 EXPERIMENTAL
 create mode 100644 config.m4
 create mode 100644 config.w32
 create mode 100644 hylog.c
 create mode 100644 hylog.php
 create mode 100644 php_hylog.h
 create mode 100644 tests/001.phpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么要这么做呢？其实主要是想让这个目录干净，因为待会儿执行了一些命令之后会生成很多文件，如果你想清除这些文件就变得很麻烦。但现在我只把这些文件&lt;code&gt;commit&lt;/code&gt;了，待会儿生成文件后，如果我想删除，就可以用&lt;code&gt;git clean -df&lt;/code&gt;，立即回到现在的状态。但关于&lt;code&gt;git&lt;/code&gt;的操作，那就是另外一回事了（强烈推荐&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;廖雪峰的git教程&lt;/a&gt;)。&lt;/p&gt;

&lt;h3 id=&#34;编译进php&#34;&gt;编译进PHP&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重新生成配置文件&lt;/p&gt;

&lt;p&gt;注意其中的&lt;code&gt;./buildconf --force&lt;/code&gt;，之所以带&lt;code&gt;--force&lt;/code&gt;是因为我们是在正式版的PHP源码中进行操作的，正常情况下使用这种方式编译的都是内建扩展，例如&lt;code&gt;PDO&lt;/code&gt;这种，是PHP官方团队开发的，所以你非要用这种方式编译的话，就强制一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) cd ..
➜  ext cd ..
➜  php-7.0.5 ./buildconf --force
Forcing buildconf
Removing configure caches
buildconf: checking installation...
buildconf: autoconf version 2.69 (ok)
rebuilding aclocal.m4
rebuilding configure
rebuilding main/php_config.h.in
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找变化&lt;/p&gt;

&lt;p&gt;刚刚的操作背后发生了什么呢？注意&lt;code&gt;rebuilding&lt;/code&gt;的三行，那我们就挨个看看。分别在三个文件中搜索&lt;code&gt;hylog&lt;/code&gt;关键字吧。
在&lt;code&gt;aclocal.m4&lt;/code&gt;中未找到变化。
在&lt;code&gt;configure&lt;/code&gt;中有大量变化，稍后介绍能看到的变化。
在&lt;code&gt;main/php_config.h.in&lt;/code&gt;中，增加了两行，用来取消&lt;code&gt;COMPILE_DL_HYLOG&lt;/code&gt;的定义，表示该扩展不是动态加载。&lt;/p&gt;

&lt;p&gt;这时检查一下&lt;code&gt;configure --help&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --help | grep hylog
  --enable-hylog           Enable hylog support
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诶，有点眼熟对不对？就是刚才在&lt;code&gt;ext/hylog/config.m4&lt;/code&gt;中取消注释的内容。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编译PHP&lt;/p&gt;

&lt;p&gt;既然要把它编译进来，那就加上&lt;code&gt;--enable-hylog&lt;/code&gt;吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --enable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看已安装的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 php -v
PHP 7.0.5 (cli) (built: Apr  9 2016 11:08:08) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
➜  php-7.0.5 php -m
[PHP Modules]
Core
ctype
date
dom
fileinfo
filter
hash
hylog
iconv
json
libxml
pcre
PDO
pdo_sqlite
Phar
posix
Reflection
session
SimpleXML
SPL
sqlite3
standard
tokenizer
xml
xmlreader
xmlwriter
    
[Zend Modules]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看到我们新创建的扩展已经编译进PHP了——虽然它没有任何功能。可以再到&lt;code&gt;/usr/local/lib/php/extensions/no-debug-non-zts-20151012&lt;/code&gt;中验证一下是不是真的没有&lt;code&gt;hylog.so&lt;/code&gt;存在。&lt;/p&gt;

&lt;p&gt;所以如果不想用它了怎么办呢？你当然可以选择无视它，但最好还是卸载了吧，卸载的方法也很简单，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --disable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来就是三行，其实要用很长时间，所以，像我们这样的第三方扩展开发者还是不要用这种方式比较好。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;动态加载&#34;&gt;动态加载&lt;/h3&gt;

&lt;p&gt;动态加载方式是把每个扩展编译成一个单独的&lt;code&gt;.so&lt;/code&gt;文件，然后在&lt;code&gt;php.ini&lt;/code&gt;中加上&lt;code&gt;extension=hylog.so&lt;/code&gt;，如果有配置就再加上一些配置。CLI的话就直接生效了，FPM环境下就要重启一下FPM了。我们这里只讨论CLI模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方扩展安装的一般流程&lt;/p&gt;

&lt;p&gt;还记得我刚刚提到的执行某些命令后会生成很多文件吗？就是这里了。如果你还没有用&lt;code&gt;git&lt;/code&gt;，我劝你现在用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) phpize
Configuring for:
PHP Api Version:         20151012
Zend Module Api No:      20151012
Zend Extension Api No:   320151012
➜  hylog git:(master) ✗ ./configure
➜  hylog git:(master) ✗ make
➜  hylog git:(master) ✗ sudo make install
Installing shared extensions:     /usr/local/lib/php/extensions/no-debug-non-zts-20151012/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，到这里已经看到在独立编译动态扩展时，生成的&lt;code&gt;.so&lt;/code&gt;文件是放在了这个目录下的。这时动态的好处就体现出来了。文件有了，至于你想不想用，只需要修改&lt;code&gt;php.ini&lt;/code&gt;即可，不用任何重新编译。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装和卸载扩展&lt;/p&gt;

&lt;p&gt;前面说了，如果需要该扩展，编辑&lt;code&gt;/usr/local/lib/php.ini&lt;/code&gt;，在最下面添加（安装）或删除（卸载）一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;extension=hylog.so
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调试&lt;/p&gt;

&lt;p&gt;我可不敢保证代码一次就能成功，调试的时候要多次执行以上三个命令，所以可以创建一个&lt;code&gt;rebuild.sh&lt;/code&gt;脚本，运行脚本重新编译并安装最新的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最好把它加入到&lt;code&gt;git&lt;/code&gt;工作目录中。&lt;/p&gt;

&lt;p&gt;扩展的安装就这些，下一节介绍PHP变量的基本类型。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——用PHP实现类的原型</title>
      <link>http://unixera.com/php/internals/class-prototype-in-php/</link>
      <pubDate>Sat, 09 Apr 2016 21:55:00 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/internals/class-prototype-in-php/</guid>
      <description>&lt;p&gt;在编写之前先用PHP实现这个类的原型吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace Hylog;

use \DateTime;

class Hylog
{
    const HYLOG_VERSION = &amp;quot;0.1.0&amp;quot;;

    const EMERGENCY = &#39;EMERGENCY&#39;;
    const ALERT     = &#39;ALERT&#39;;
    const CRITICAL  = &#39;CRITICAL&#39;;
    const ERROR     = &#39;ERROR&#39;;
    const WARNING   = &#39;WARNING&#39;;
    const NOTICE    = &#39;NOTICE&#39;;
    const INFO      = &#39;INFO&#39;;
    const DEBUG     = &#39;DEBUG&#39;;

    private static $_instance;

    private $_basePath;
    private $_sliceLogByHour;

    public function log($level, $message, $context = array())
    {
        $line = $this-&amp;gt;interpolate($message, $context);

        $datetime         = new DateTime();
        $timestamp        = $datetime-&amp;gt;getTimestamp();
        $formatedDatetime = $datetime-&amp;gt;format(DateTime::ATOM);

        $line = $timestamp . &amp;quot;\t|\t&amp;quot; . $formatedDatetime . &amp;quot;\t|\t&amp;quot; . $line;

        $this-&amp;gt;output($level, $line);
    }

    public function emergency($message, $context = array())
    {
        $this-&amp;gt;log(self::EMERGENCY, $message, $context);
    }

    public function alert($message, $context = array())
    {
        $this-&amp;gt;log(self::ALERT, $message, $context);
    }

    public function critical($message, $context = array())
    {
        $this-&amp;gt;log(self::CRITICAL, $message, $context);
    }

    public function error($message, $context = array())
    {
        $this-&amp;gt;log(self::ERROR, $message, $context);
    }

    public function warning($message, $context = array())
    {
        $this-&amp;gt;log(self::WARING, $message, $context);
    }

    public function notice($message, $context = array())
    {
        $this-&amp;gt;log(self::NOTICE, $message, $context);
    }

    public function info($message, $context = array())
    {
        $this-&amp;gt;log(self::INFO, $message, $context);
    }

    public function debug($message, $context = array())
    {
        $this-&amp;gt;log(self::DEBUG, $message, $context);
    }

    public static function getInstance() : object
    {
        if (!isset(self::$_instance)) {
            self::$_instance = new static();
        }

        return self::$_instance;
    }

    public function getVersion()
    {
        return self::HYLOG_VERSION;
    }

    public function setBasePath($path)
    {
        $this-&amp;gt;_basePath = $path;
    }

    public function getBasePath() : string
    {
        return $this-&amp;gt;_basePath;
    }

    public function setSliceByHour($bool)
    {
        $this-&amp;gt;_sliceLogByHour = $bool;
    }

    public function getSliceByHour() : bool
    {
        return $this-&amp;gt;_sliceLogByHour;
    }

    private function output($level, $message)
    {
        $logFile = $this-&amp;gt;getLogFile($level);

        error_log($message . PHP_EOL, 3, $logFile);
    }

    private function getLogFile($level) : string
    {
        $cHour = date(&#39;ymdH&#39;);
        $cDay  = date(&#39;ymd&#39;);

        if ($this-&amp;gt;_sliceLogByHour) {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cHour . &#39;.log&#39;;
        } else {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cDay . &#39;.log&#39;;
        }
    }

    private function interpolate($message, $context = array())
    {
        foreach ($context as $key =&amp;gt; $val) {
            $replace[&#39;{&#39; . $key . &#39;}&#39;] = $val;
        }

        return strtr($message, $replace);
    }

    private function __construct()
    {
        $this-&amp;gt;_basePath = &#39;/tmp/log&#39;;

        if (!is_dir($this-&amp;gt;_basePath)) {
            mkdir($this-&amp;gt;_basePath, 0700, true);
        } else {
            chmod($this-&amp;gt;_basePath, 0700);
        }

        $this-&amp;gt;_sliceLogByHour = true;
    }

    private function __clone()
    {
    }

    private function __wakeup()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——目标和计划</title>
      <link>http://unixera.com/php/internals/schedules/</link>
      <pubDate>Sat, 09 Apr 2016 21:13:28 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/internals/schedules/</guid>
      <description>

&lt;p&gt;好了，现在来整理一下我们要做的工作。&lt;/p&gt;

&lt;h2 id=&#34;功能目标&#34;&gt;功能目标&lt;/h2&gt;

&lt;p&gt;既然是要做一个记日志的扩展，那当然就避免不了两个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;格式化日志流&lt;/li&gt;
&lt;li&gt;将日志流推送到特定目标（通常是写入文件）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个是最核心的功能，其他的都是辅助。但辅助也可以很贴心，所以我设计了以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽可能多的从扩展层面获取共用的信息，比如时间、客户端IP、当前机器的IP等（这里涉及&lt;strong&gt;超全局变量&lt;/strong&gt;的获取）&lt;/li&gt;
&lt;li&gt;设计尽量简单的默认规则，既可以开箱即用，又可以随心配置&lt;/li&gt;
&lt;li&gt;遵守&lt;a href=&#34;http://www.php-fig.org/psr/psr-3/&#34;&gt;PSR-3&lt;/a&gt;规范&lt;/li&gt;
&lt;li&gt;命名空间和传统写法的兼容(鸟哥的Yaf是教科书）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个需要考虑的问题是高并发场景下的文件写入丢失问题，我觉得以我目前的水平是无法解决这个问题的，那没关系，PHP内置的已经有强大的&lt;code&gt;error_log&lt;/code&gt;方法了，它可以保证这点，用它就可以。喂等等，那既然已经有了&lt;code&gt;error_log&lt;/code&gt;，我干嘛还要做这个呢？&lt;/p&gt;

&lt;p&gt;因为它不够灵活。&lt;/p&gt;

&lt;p&gt;我们通常的做法是封装&lt;code&gt;error_log&lt;/code&gt;方法，填充默认参数、格式化、写入文件等，&lt;code&gt;error_log&lt;/code&gt;方法本身是很快的，但挡不住我们添加的这些代码的消耗也很大，因为写日志是个非常频繁的操作，所以一个极小的性能损失积累下来都可能影响很大。&lt;/p&gt;

&lt;h2 id=&#34;取名&#34;&gt;取名&lt;/h2&gt;

&lt;p&gt;既然用C写，那就是奔着高性能去的，High Performance PHP Log，叫Hilog貌似就可以，但为了致敬鸟哥，把i换成y好了：）所以叫Hylog。&lt;/p&gt;

&lt;h2 id=&#34;类的设计&#34;&gt;类的设计&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;拥有PRS-3规定的8个level作为常量&lt;/li&gt;
&lt;li&gt;对应8个方法，分别写到不同的文件&lt;/li&gt;
&lt;li&gt;一个log方法比上述8个方法多个level参数，上述8个函数实际是调用这个方法记日志的&lt;/li&gt;
&lt;li&gt;格式化日志的方法&lt;/li&gt;
&lt;li&gt;数组插值的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;依赖关系&#34;&gt;依赖关系&lt;/h2&gt;

&lt;p&gt;依赖PHP内置函数&lt;code&gt;error_log&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用PHP生成器和迭代器</title>
      <link>http://unixera.com/php/php-generator-and-iterator/</link>
      <pubDate>Tue, 05 Apr 2016 12:05:46 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/php-generator-and-iterator/</guid>
      <description>

&lt;p&gt;从开始写PHP就知道迭代器这个东西，当时师傅告诉我用的挺少的，需要的时候再看也不晚，于是就没有放在意上。但他还说这其实也是区分高手和菜鸟的一个标志，那我还是研究一下好了：）&lt;/p&gt;

&lt;p&gt;PHP程序员都知道我们最经常用的可能就是&lt;code&gt;foreach&lt;/code&gt;这个大杀器了。得益于我们&lt;strong&gt;万能的数组&lt;/strong&gt;，所以这个大杀器在多数场合都是可以直接用的，只要输入元素是数组类型即可——事实上并不是如此，&lt;code&gt;foreach&lt;/code&gt;能遍历数组并不是因为它是数组，而是因为数组&lt;code&gt;implements&lt;/code&gt;了&lt;code&gt;Iterator&lt;/code&gt;接口。说白了就是只要告诉&lt;code&gt;foreach&lt;/code&gt;遍历的规则，它就可以执行遍历，而和是否数组无关。&lt;/p&gt;

&lt;h3 id=&#34;iterator&#34;&gt;Iterator&lt;/h3&gt;

&lt;h4 id=&#34;解析&#34;&gt;解析&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;接口定义了5个方法，如果一个类要实现&lt;code&gt;Iterator&lt;/code&gt;接口，当然就要实现这一套方法了。&lt;code&gt;Iterator&lt;/code&gt;的原型如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Interface Iterator
{
	abstract public function current() : mixed;
	abstract public function key() : scalar;
	abstract public function next() : void;
	abstract public function rewind() : void;
	abstract public function valid() : boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我在方法后面按照PHP7的新语法加了个返回值类型，其实这样写是不对的，但可以表明意思啦：）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细说一下这几个方法要做的事情。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;current()&lt;/p&gt;

&lt;p&gt;返回当前位置的&lt;strong&gt;值&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;key()&lt;/p&gt;

&lt;p&gt;返回当前位置的&lt;strong&gt;键&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;next()&lt;/p&gt;

&lt;p&gt;当前位置的&lt;strong&gt;键&lt;/strong&gt;加1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rewind()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;键&lt;/strong&gt;回到第一个位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;valid()&lt;/p&gt;

&lt;p&gt;返回当前的&lt;strong&gt;键&lt;/strong&gt;是否是有意义的。如是否是&lt;code&gt;false&lt;/code&gt;/&lt;code&gt;NULL&lt;/code&gt;等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;

&lt;p&gt;还是来具体写个例子理解一下吧。通常写这种例子的作者都会举一个类，它的一个属性是个数组，然后实现&lt;code&gt;Iterator&lt;/code&gt;的5个方法，来让这个类可以使用&lt;code&gt;foreach&lt;/code&gt;，这个例子没意思，因为数组本身就带&lt;code&gt;current&lt;/code&gt;、&lt;code&gt;key&lt;/code&gt;这些方法。让我来举一个&lt;code&gt;pdo_mysql&lt;/code&gt;从数据库中取数据的例子吧。&lt;/p&gt;

&lt;p&gt;从数据库取出一一个数组，数组中的元素是&lt;code&gt;User&lt;/code&gt;类的实例，我们需要&lt;code&gt;Users&lt;/code&gt;类的方法，它又要有一些方法。所以，就产生了这样的用法了。这个例子可能有些牵强，但起码描述了一个使用场景，比单纯的迭代一个类的类型为数组的属性要有意义。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git.coding.net/lovelock/iterator_example.git&#34;&gt;代码地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generator&#34;&gt;Generator&lt;/h3&gt;

&lt;p&gt;只有真正理解了&lt;code&gt;Iterator&lt;/code&gt;才能再来谈&lt;code&gt;Generator&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还是举例来说，前面已经说了一个比较复杂的例子，这里为了说明二者的区别，举个简单的例子。&lt;/p&gt;

&lt;p&gt;假定有一个日志文件，1000000行吧，很大了？或许吧。现在我们要遍历这个文件，找到我们需要的东西。如果使用&lt;code&gt;Iterator&lt;/code&gt;，可能需要这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class LinesIterator implements Iterator
{
	private $_fp;
	private $_currentLine;
	private $_lineNum;

	public function __construct($filename)
	{
		$this-&amp;gt;_fp = fopen($filename, &#39;r&#39;);
		$this-&amp;gt;_lineNum = 0;
	}

	public function current()
	{
		$this-&amp;gt;_currentLine = fgets($this-&amp;gt;_fp);
		return $this-&amp;gt;_currentLine;
	}

	public function key()
	{
		return $this-&amp;gt;_lineNum;
	}

	public function valid()
	{
		return $this-&amp;gt;_currentLine === false;
	}

	public function next()
	{
		fgets($this-&amp;gt;_fp);
		$this-&amp;gt;_lineNum++;
	}

	public function rewind()
	{
	}

	public function __destruct()
	{
		fclose($this-&amp;gt;_fp);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要遍历文件时，可以这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$file = new LinesIterator(&#39;file&#39;);

foreach ($file-&amp;gt;current() as $line) {
	echo $line;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这没有问题，但也太复杂了吧！！！重点是即使我实现了这些，但还是无法随便定位到某一行（这需要&lt;code&gt;fseek&lt;/code&gt;）。所以这种场景下，&lt;code&gt;Generator&lt;/code&gt;出现了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function getLine($fileName)
{
	$fp = fopen($fileName, &#39;r&#39;);	

	while ($line = fgets($fp) !== false) {
		yield $line;
	}

	fclose($fp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就简明多了。&lt;code&gt;Generator&lt;/code&gt;的标志就是&lt;code&gt;yield&lt;/code&gt;，这点在所有编程语言里都一样。&lt;/p&gt;

&lt;p&gt;正常如果在用&lt;code&gt;yield&lt;/code&gt;的地方用了&lt;code&gt;return&lt;/code&gt;，那么代码执行到这里就结束了，下次再执行这个函数时，还是从头开始，我们永远得不到文件的第二行。那么怎么办呢？我的理解是&lt;code&gt;Generator&lt;/code&gt;把这行内容返回的同时，也把文件句柄所在的指针向后移动了一个单位，下次再次执行该函数时，就会从上次的位置继续执行。&lt;/p&gt;

&lt;p&gt;这个函数的功能和上面那个类的效果完全相同。&lt;/p&gt;

&lt;p&gt;还有一点要提一下，&lt;code&gt;Generator&lt;/code&gt;通常用来处理文件特别大的情况，比如上面这样，文件太大，如果直接用&lt;code&gt;file&lt;/code&gt;读进来保存成为一个数组，很可能就会报错。而如果用&lt;code&gt;Generator&lt;/code&gt;就没有这个问题了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——背景介绍</title>
      <link>http://unixera.com/php/internals/introduction/</link>
      <pubDate>Mon, 04 Apr 2016 22:37:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/internals/introduction/</guid>
      <description>

&lt;p&gt;这段时间其实在看C语言，但看来看去也不知道学了这些知识用在哪里。作为一名PHP程序员，想要进阶，当然得懂PHP的运行原理。那么，编写扩展就成了认识PHP的必经之路。而PHP的扩展当然是用C写的，这样，也给自己刚刚学的C语言找到了练手的项目。&lt;/p&gt;

&lt;p&gt;那么写个什么项目好呢？最好简单一些，但也要能涵盖编写一个完整功能的扩展的方方面面。忘了在哪里看到了&lt;a href=&#34;https://github.com/Neeke/SeasLog&#34;&gt;SeasLog&lt;/a&gt;，感觉这个项目很符合我的期望，于是上它的issue列表里面找到了一个功能请求，作者还没有着手做，那我就顺手帮忙做了吧，前几天已经被作者合并了，让我的信心也倍增。所以，我决定自己也再写一个类似的东西，主要目的是通过做一个完整的项目，各个击破PHP扩展编写过程中的所有问题。&lt;/p&gt;

&lt;p&gt;言归正传，先列上参考文献列表好了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpinternalsbook.com/&#34;&gt;PHP internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/walu/phpbook&#34;&gt;PHP扩展开发及内核应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/en/internals2.php&#34;&gt;PHP at the core: A Hacker&amp;rsquo;s Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/yaf&#34;&gt;Yaf源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.php.net/downloads.php&#34;&gt;PHP源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/php7-internal&#34;&gt;Understanding PHP7 Internal articles&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;声明&#34;&gt;声明：&lt;/h2&gt;

&lt;p&gt;本系列所描述的PHP扩展相关知识大部分基于PHP 7.0.x，与PHP 5.x不完全兼容，因为列表里的前三个文献都是讲PHP5的，所以我在编写本文时也碰到了不少兼容性问题，都是通过看Yaf源码和PHP源码搞定兼容性的，我没有提到的地方还请在留言中指出。我当然也希望我的这份绵薄之力能帮助弥补目前PHP7相关文档严重不足的情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>seaslog 和 error_log性能大比拼</title>
      <link>http://unixera.com/php/log-bench/</link>
      <pubDate>Fri, 01 Apr 2016 16:33:19 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/log-bench/</guid>
      <description>

&lt;p&gt;今天花了点时间测试了开源项目&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;seaslog&lt;/a&gt;和PHP内置的error_log的性能。本文不涉及该扩展的安装和使用，如果对其不了解，可移步&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;项目的描述有语法问题&amp;rdquo;A effective &amp;hellip;&amp;ldquo;，我提醒了原作者，然而并没有被理会。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Intel&amp;reg; Xeon&amp;reg; CPU  E5520  @ 2.27GHz 8核&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;48G&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;7.0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nginx&lt;/td&gt;
&lt;td&gt;1.2.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试代码&#34;&gt;测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

error_log(&amp;quot;I am testing performance of error_log&amp;quot; . PHP_EOL, 3, __DIR__ . &#39;/error_log.log&#39;);
SeasLog::debug(&amp;quot;I am testing performance of seaslog&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果数据&#34;&gt;结果数据&lt;/h2&gt;

&lt;p&gt;每种方式测试5次，请求次数1000次，并发量分别是1, 10, 100, 1000。分别记录每次测试的QPS。&lt;/p&gt;

&lt;p&gt;1. error_log&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2430&lt;/td&gt;
&lt;td&gt;2579&lt;/td&gt;
&lt;td&gt;2685&lt;/td&gt;
&lt;td&gt;2484&lt;/td&gt;
&lt;td&gt;2622&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7303&lt;/td&gt;
&lt;td&gt;7844&lt;/td&gt;
&lt;td&gt;5892&lt;/td&gt;
&lt;td&gt;11739&lt;/td&gt;
&lt;td&gt;9002&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;11763&lt;/td&gt;
&lt;td&gt;6107&lt;/td&gt;
&lt;td&gt;6921&lt;/td&gt;
&lt;td&gt;9258&lt;/td&gt;
&lt;td&gt;11999&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;889&lt;/td&gt;
&lt;td&gt;883&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2. seaslog&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2147&lt;/td&gt;
&lt;td&gt;2071&lt;/td&gt;
&lt;td&gt;2130&lt;/td&gt;
&lt;td&gt;2123&lt;/td&gt;
&lt;td&gt;2039&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7415&lt;/td&gt;
&lt;td&gt;9438&lt;/td&gt;
&lt;td&gt;6901&lt;/td&gt;
&lt;td&gt;6445&lt;/td&gt;
&lt;td&gt;6047&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;7770&lt;/td&gt;
&lt;td&gt;9389&lt;/td&gt;
&lt;td&gt;6852&lt;/td&gt;
&lt;td&gt;5806&lt;/td&gt;
&lt;td&gt;6483&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;890&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;760&lt;/td&gt;
&lt;td&gt;322&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试结果图&#34;&gt;测试结果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/errorlog.png&#34; alt=&#34;error_log性能测试结果&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/seaslog.png&#34; alt=&#34;seaslog性能测试结果&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;error_log的性能总体优于seaslog，但并没有压倒性优势&lt;/li&gt;
&lt;li&gt;在并发较高时二者都出现急剧性能下降，程度相当。怀疑瓶颈已经不在写日志，而在Nginx的处理能力了（待验证）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;seaslog使用起来更简单，不需要多层封装&lt;/li&gt;
&lt;li&gt;error_log输出的格式比较单一，如果要加上日期、IP等信息，一定会引入很多PHP函数调用，导致性能损失。但seaslog在这方面就有很大的想象空间，在扩展中计算时间、获取IP、详细的debug信息都是可能的。不过现在并没有加入这些功能。&lt;/li&gt;
&lt;li&gt;seaslog提供了类似PDO的插值方式，使用起来更方便&lt;/li&gt;
&lt;li&gt;seaslog可以自定义配置多&lt;/li&gt;
&lt;li&gt;一个细节，error_log在type=3时并没有在message后面加上换行符，需要自行添加，也就是说每次都要有一个字符串拼接，这在seaslog中得到了改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我之前看到有人说seaslog的日期格式太固定，因此我fork了一份代码加上了配置日期格式的功能，作者到现在都没有合并进主干呢。而且我觉得现在这个功能有些简陋，比如我前面说的第2点，请求的一些基本信息如果从扩展层面直接取到，就不需要再在外层调用PHP函数或通过超全局变量获取了，既简化了外层使用的方式，又提高性能。但作者貌似也没有继续增加功能的意思，可能作者并不想在扩展层面做太复杂的事情，要保持这个项目的简单、纯粹。&lt;/p&gt;

&lt;p&gt;我还是自己再维护一份好了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>检测浏览器是否安装了Flash</title>
      <link>http://unixera.com/javascript/detect-flash/</link>
      <pubDate>Wed, 30 Mar 2016 16:08:03 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/javascript/detect-flash/</guid>
      <description>&lt;p&gt;现在国内竟然那么多的视频网站都还不支持HTML5的视频播放，无外乎几个原因：&lt;/p&gt;

&lt;p&gt;现在我们的浏览器也只是对Safari开启了默认HTML5，而其他浏览器都是&lt;strong&gt;鼓励&lt;/strong&gt;用户使用Flash的，但我觉得这样不好。&lt;/p&gt;

&lt;p&gt;下面的代码可以用来检测用户是否装了Flash。其实我不需要知道Flash的版本，因为任何的版本都应该是支持视频播放的。如果有些其他功能需要高版本的Flash，那也是用户安装了之后的事情了，API受限的或者有安全漏洞的话，浏览器会提示用户更新。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function detectFlash() {
    if (navigator.mimeTypes.length &amp;gt; 0) {
        var flashAct = navigator.mimeTypes[&amp;quot;application/x-shockwave-flash&amp;quot;];
        return flashAct != null ? flashAct.enabledPlugin != null : false;
    } else if (self.ActiveXObject) {
        try {
            new ActiveXObject(&#39;ShockwaveFlash.ShockwaveFlash&#39;);
            return true;
        } catch (oError) {
            return false;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>用vimdiff作为svn/git的diff工具</title>
      <link>http://unixera.com/vim/vimdiff-as-subversion-diff/</link>
      <pubDate>Mon, 07 Mar 2016 12:06:45 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/vim/vimdiff-as-subversion-diff/</guid>
      <description>&lt;p&gt;前后两家公司都是用Subversion做版本控制，虽说程序员自己有喜好，但仍然需要遵守公司的规定。我个人是比较偏好直接登录服务器进行开发的，所以得配置好各种好用的命令行工具。比如svn提交之前需要diff一下所做的修改，默认的diff工具简直没用什么卵用。屏幕那么短，上下显示不直观。&lt;/p&gt;

&lt;p&gt;发现gist.github.com一直上不去，干脆就把它集成到我自己维护的&lt;a href=&#34;https://github.com/lovelock/hackvim&#34;&gt;hackvim&lt;/a&gt;里了，这里先加一个svn的配置，稍后回家把git的也加上。&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先切换到你想要放hackvim的目录，我喜欢~/Projects&lt;/li&gt;
&lt;li&gt;git clone &lt;a href=&#34;https://github.com/lovelock/hackvim&#34;&gt;https://github.com/lovelock/hackvim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果你想用我的vim发行版，就看下项目的说明，否则直接拿出来utils/svnvimdiff.sh，放在你希望的位置&lt;/li&gt;
&lt;li&gt;进入~/.subversion&lt;/li&gt;
&lt;li&gt;打开config文件，修改&lt;code&gt;diff-cmd = /path/to/svnvimdiff.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;done&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意vimdiff.sh文件必须是可执行的。我在提交之前已经加了755，如果出错，请自行检查一下。&lt;/p&gt;

&lt;p&gt;Git默认的也是用系统预装的diff工具，所以还可以给git加个配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global diff.tool vimdiff
git config --global difftool.prompt false
git config --global alias.d difftool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完之后，执行&lt;code&gt;git d&lt;/code&gt;就可以呼出&lt;code&gt;vimdiff&lt;/code&gt;了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrap插件DataTables实现服务器端分页</title>
      <link>http://unixera.com/javascript/bootstrap-plugin-datatables/</link>
      <pubDate>Sun, 28 Feb 2016 21:40:04 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/javascript/bootstrap-plugin-datatables/</guid>
      <description>

&lt;p&gt;我们知道，PHP和MySQL实现分页的基本思路是limit，页面上有个page(第几页）和count(每次取出几个），PHP把它传递给后端MySQL，查询时在条件查询的基础上加上&lt;code&gt;limit {($page - 1) * $count, $count}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但是，自己实现PHP分页也是有不少繁琐的问题需要解决的，比如分页要最多显示几个，两头如何处理，样式设计等等，既然有了Bootstrap这个大框架，各种解决方案就层出不穷了。&lt;/p&gt;

&lt;p&gt;废话不多说，今天要讲一下用Bootstrap的插件DataTables做一个带分页的表格。&lt;/p&gt;

&lt;p&gt;DataTables官方文档给的例子是一次把数据取出，然后在前端做分页处理。这样的好处是减少了每次查询都要请求网络，坏处则是如果数据太多，前端肯定就扛不住了。文档也说了，如果数据量在10000以内，可以在前端做分页，100000以上就在服务端做，中间的量就衡量自己的数据和服务器的处理能力做决定了。&lt;/p&gt;

&lt;p&gt;本文的基础是PHP内置Web Server和Bootstrap的模板SB-Admin2。&lt;/p&gt;

&lt;h2 id=&#34;前端处理分页&#34;&gt;前端处理分页&lt;/h2&gt;

&lt;p&gt;最直观的方法就是把所有的数据自己组织好，用foreach组织&lt;code&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/code&gt;，再加上一个&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，插件就会帮你把你想要的效果展示出来了，再加上实时搜索，效果简直不能更赞。&lt;/p&gt;

&lt;p&gt;但这在实际应用中用的应该还是比较少，毕竟稍微上点规模的公司需要处理的内容就不止10000那么少了。&lt;/p&gt;

&lt;h2 id=&#34;后端处理分页&#34;&gt;后端处理分页&lt;/h2&gt;

&lt;p&gt;先要理解几个概念。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;draw 请求的当前次数&lt;/li&gt;
&lt;li&gt;start 返回结果的开始位置&lt;/li&gt;
&lt;li&gt;length 返回结果的长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我这里为了简单起见，把数组当做数据源了，根据传入的参数不同，返回数组的不同部分。&lt;/p&gt;

&lt;p&gt;一般来说，返回的数据里需要这些字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;draw&amp;quot;: 1,
  &amp;quot;recordsTotal&amp;quot;: 57,
  &amp;quot;recordsFiltered&amp;quot;: 57,
  &amp;quot;data&amp;quot;: [
    [
      &amp;quot;Airi&amp;quot;,
      &amp;quot;Satou&amp;quot;,
      &amp;quot;Accountant&amp;quot;,
      &amp;quot;Tokyo&amp;quot;,
      &amp;quot;28th Nov 08&amp;quot;,
      &amp;quot;$162,700&amp;quot;
    ],
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在页面上需要有&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;table class=&amp;quot;table table-striped table-bordered table-hover&amp;quot; id=&amp;quot;datatable-example&amp;quot;&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;Column1&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Column2&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Column3&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Column4&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Column5&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Column6&amp;lt;/th&amp;gt;
        &amp;lt;tr&amp;gt;
    &amp;lt;/thead&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true,
        serverSide: true,
        processing: true,
        ajax: &amp;quot;ajax.php&amp;quot;
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，serverSide选项表示使用服务端分页，processing表示加载表格的时候会在表格上覆盖一个『加载中』的类似弹层，而ajax就是数据的来源了。具体代码见。。&lt;/p&gt;

&lt;p&gt;那你可能要说了，我的数据返回的可是正宗的HashTable，我指明是HashTable是因为PHP中数组也是HashTable，指的是Python里的字典。该怎么办呢？&lt;/p&gt;

&lt;p&gt;相应的，如果返回的每列数据是这样的(其实这才是从数据库中取出来的样子)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
      &amp;quot;first_name&amp;quot;: &amp;quot;Jennifer&amp;quot;,
      &amp;quot;last_name&amp;quot;: &amp;quot;Chang&amp;quot;,
      &amp;quot;position&amp;quot;: &amp;quot;Regional Director&amp;quot;,
      &amp;quot;office&amp;quot;: &amp;quot;Singapore&amp;quot;,
      &amp;quot;start_date&amp;quot;: &amp;quot;14th Nov 10&amp;quot;,
      &amp;quot;salary&amp;quot;: &amp;quot;$357,650&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那只需要把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true,
        serverSide: true,
        processing: true,
        ajax: &amp;quot;ajax.php&amp;quot;
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true,
        serverSide: true,
        processing: true,
        ajax: &amp;quot;ajax.php&amp;quot;,
        columns: [
            { &amp;quot;data&amp;quot;: &amp;quot;first_name&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;last_name&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;position&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;office&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;start_date&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;salary&amp;quot; }
        ]
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以了。&lt;/p&gt;

&lt;p&gt;这是数据库的最简单的情况，那如果我用了ORM，取出来的就是对象了，这就免不了『嵌套对象』了。不管是Python的数组（PHP中key是数组的）还是字典（PHP中key是字符串的），都是一样的处理方式，都是最直观的表示法，把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true,
        serverSide: true,
        processing: true,
        ajax: &amp;quot;ajax.php&amp;quot;,
        columns: [
            { &amp;quot;data&amp;quot;: &amp;quot;first_name&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;last_name&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;position&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;office&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;start_date&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;salary&amp;quot; }
        ]
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    $(&#39;#datatable-example&#39;).DataTable({
        responsive: true,
        serverSide: true,
        processing: true,
        ajax: &amp;quot;ajax.php&amp;quot;,
        columns: [
            { &amp;quot;data&amp;quot;: &amp;quot;first_name&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;last_name.other&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;position.2&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;office&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;start_date&amp;quot; },
            { &amp;quot;data&amp;quot;: &amp;quot;salary&amp;quot; }
        ]
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Git钩子自动部署代码</title>
      <link>http://unixera.com/git/git-deploy-hook/</link>
      <pubDate>Sun, 21 Feb 2016 15:37:20 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/git/git-deploy-hook/</guid>
      <description>

&lt;p&gt;前几天在&lt;a href=&#34;https://bandwagonhost.com/&#34;&gt;搬瓦工&lt;/a&gt;上买了个年费19.99刀的VPS，想着用来做一些研究，毕竟在公网上，做什么事情都更方便点。虽然机器的性能尚可，就是网络稍慢。不过好在发现速度慢时可以切换一下机房，数据也没有损失，一分钟即可搞定，这点简直是搬瓦工的杀手锏。&lt;/p&gt;

&lt;p&gt;其实是前几天我去一家公司面试，面试官跟我提到他们之前用过Laravel，发现性能像屎一样，一般框架的性能影响可以忽略不计，性能消耗可能都在数据库IO上，但Laravel不一样，性能真的消耗在了框架上。。。。这就让我萌生了一个念头，自己测试一下到底我们敬爱的鸟哥写的Yaf，和我喜欢的Symfony及其精简版Silex还有号称为艺术家而生的框架Laravel及其精简版Lumen的性能。&lt;/p&gt;

&lt;p&gt;环境部署我就不说了，直接上配置说明&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-21%20%E4%B8%8B%E5%8D%883.49.05.png&#34; alt=&#34;操作系统版本&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-21%20%E4%B8%8B%E5%8D%883.47.48.png&#34; alt=&#34;PHP版本&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-21%20%E4%B8%8B%E5%8D%883.48.04.png&#34; alt=&#34;PHP模块&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;git自动部署&#34;&gt;Git自动部署&lt;/h2&gt;

&lt;p&gt;由于网络连接比较慢，在服务器上直接写代码是很浪费时间的，那我就想在本地写了代码，push到远端服务器之后，给git配上一个钩子，让它自己把最新的代码覆盖到Web目录。&lt;/p&gt;

&lt;p&gt;对，就是钩子。&lt;/p&gt;

&lt;p&gt;第一次对钩子的作用有概念还是Yaf的Plugin中的钩子，&lt;del&gt;说白了就是回调函数&lt;/del&gt;。你可以指定在某个事件发生前或者发生后做某件事。&lt;/p&gt;

&lt;p&gt;那根据需求，这个钩子应该在&lt;code&gt;/var/www/project&lt;/code&gt;中执行&lt;code&gt;git checkout -f&lt;/code&gt;命令。那总不能要cd到Web目录去执行吧，所以得先设置两个变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 要部署到的目录，在这里是`/var/www/project`
2. git的remote地址
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是具体的操作步骤。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在服务器设置git server&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;useradd -m -d /var/git git -s /usr/bin/git-shell
cd /var/git
mkdir project.git
cd project.git
git init --bare
cd hooks
echo &#39;git --work-tree=/var/www/project --git-dir=/var/git/project.git checkout -f&#39; &amp;gt; post-receive
chmod +x post-receive
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clone 代码库到本地，开始工作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@remoteserver:/var/git/project.git
cd project.git
touch a.test
git add .
git commit -m &#39;test git hook&#39;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器检查Web目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /var/www/project
ls -l
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个过程需要注意&lt;strong&gt;用户git需要有Web目录的写权限&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;基础搭好了，就可以继续了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>又一份Yaf文档——写给正在迷惑的你</title>
      <link>http://unixera.com/php/Yaf-yet-another-manual-for-human/</link>
      <pubDate>Mon, 01 Feb 2016 11:55:20 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://unixera.com/php/Yaf-yet-another-manual-for-human/</guid>
      <description>

&lt;p&gt;终于把困扰我很久的问题搞定了，好开心。趁着记忆还热乎，一定要把它记下来。&lt;/p&gt;

&lt;p&gt;前几天还和同事抱怨，用Yaf框架的人那么多，但我们身边竟然没有一个人对它的用法很清楚的。真是有些悲哀。几个同事都说鸟哥写的Yaf文档看不明白。&lt;/p&gt;

&lt;p&gt;言归正传，就我自己的学习过程来看，如果你要自己搭建一个Yaf环境，遇到的问题可能主要有以下这些：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置Nginx的rewrite规则&lt;/li&gt;
&lt;li&gt;命名空间怎么用&lt;/li&gt;
&lt;li&gt;目录结构设置&lt;/li&gt;
&lt;li&gt;插件的使用&lt;/li&gt;
&lt;li&gt;单Controller多Action配置&lt;/li&gt;
&lt;li&gt;多模块配置&lt;/li&gt;
&lt;li&gt;更多配置文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就这些问题一一给出解答。&lt;/p&gt;

&lt;h2 id=&#34;配置nginx的rewrite规则&#34;&gt;配置Nginx的rewrite规则&lt;/h2&gt;

&lt;p&gt;让我们直接忽略Apache和Lighttpd吧，默认大家都用Nginx。&lt;/p&gt;

&lt;h3 id=&#34;yaf路由规则&#34;&gt;Yaf路由规则&lt;/h3&gt;

&lt;p&gt;如果你看过官方文档，那4种路由规则我就不说了，只说最简单也是默认的&lt;code&gt;Yaf_Route_Static&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;读了Yaf源码的同学会发现，其实这个规则就是解析&lt;code&gt;request_uri&lt;/code&gt;，用&lt;code&gt;/&lt;/code&gt;把它分开，然后用每一部分去匹配Module/Controller/Action/Param。举个例子吧，假设PATH=/foo/bar/doge，更通俗一点，如果你的域名是&lt;code&gt;http://yaf.dev&lt;/code&gt;，那么这个例子中的完整URL就是&lt;code&gt;http://yaf.dev/foo/bar/doge&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;路由规则做了以下动作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;解析URL，得到PATH部分&lt;/li&gt;
&lt;li&gt;认为&lt;code&gt;foo&lt;/code&gt;是Module，去&lt;code&gt;application.modules&lt;/code&gt;配置中找&lt;code&gt;Foo&lt;/code&gt;（不区分大小写）&lt;/li&gt;
&lt;li&gt;如果找到了&lt;code&gt;modules/Foo&lt;/code&gt;，则继续认为&lt;code&gt;bar&lt;/code&gt;是Controller，查找&lt;code&gt;modules/Foo/BarController&lt;/code&gt;；没找到则会认为&lt;code&gt;foo&lt;/code&gt;是Controller，下面同4&lt;/li&gt;
&lt;li&gt;如果找到了&lt;code&gt;modules/Foo/BarController&lt;/code&gt;，则继续认为&lt;code&gt;doge&lt;/code&gt;是Action，查找&lt;code&gt;modules/Foo/BarController/dogeAction&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样是不是很清晰了？&lt;/p&gt;

&lt;h2 id=&#34;不要这样配&#34;&gt;不要这样配&lt;/h2&gt;

&lt;p&gt;老湿老湿，你不是要说Nginx的rewrite规则怎么配吗，怎么在这讲起了路由规则？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我是要告诉你不要听那些自作聪明的人(没错就是我)把rewrite规则配错!!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也就是说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rewrite ^/(.*)  /index.php/$1 last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是绝对正确的，不要看谁谁谁说这不对而写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rewrite ^/(.*)  /index.php?$1 last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这才是错误的。&lt;/p&gt;

&lt;p&gt;我的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 80;

    root /var/www/yaf.ubuntu.com/public;

    index index.php index.html;

    server_name yaf.ubuntu.com;

    location = /favicon.ico {
        access_log off;
        error_log off;
        log_not_found off;
    }

    if (!-e $request_filename) {
        rewrite ^/(.*\.(js|ico|gif|jpg|png|css|bmp|html|xls)$) /public/$1 last;
        rewrite ^/(.*)  /index.php/$1 last;
    }

    location ~ \.php {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/usr/local/var/run/php-fpm-www.sock;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个配置主要是加上了对静态文件的支持，如果没有多出来的配置，你会经常在日志中看到找不到Favicon.ico.php找不到的500报错。&lt;/p&gt;

&lt;h2 id=&#34;fpm配置&#34;&gt;FPM配置&lt;/h2&gt;

&lt;p&gt;那好，路由规则明白了，rewrite规则好了，毕竟我是PHP脚本啊，得有FPM吧。通常来说，Nginx会给你一个默认的配置，以Debian为例，用apt安装的Nginx自带的default配置&lt;code&gt;location ~ \.php$&lt;/code&gt;段如下（已删除注释，我喜欢用unix socket，不服来打我啊）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ \.php$ {
	include snippets/fastcgi-php.conf;
	fastcgi_pass unix:/var/run/php7.0-fpm.sock;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样没问题，但也仅限于&lt;code&gt;http://yaf.dev/xxxx.php&lt;/code&gt;这种请求。别的都匹配不到啊，别忘了，你请求URL可不是这样的。&lt;/p&gt;

&lt;p&gt;所以，只要它是个请求，都要让它可以经过FPM。改成这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
	include snippets/fastcgi-php.conf;
	fastcgi_pass unix:/var/run/php7.0-fpm.sock;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，把这两部分保存一下，重启一下Nginx服务&lt;code&gt;sudo systemctl restart nginx&lt;/code&gt;，访问一下，哈，爽。&lt;/p&gt;

&lt;h3 id=&#34;静态文件怎么办&#34;&gt;静态文件怎么办？&lt;/h3&gt;

&lt;p&gt;这样配置，访问Action什么的是没问题了，但如果要访问这个域名下的静态文件，css/js啥的，就有问题了，这就需要在上面的&lt;code&gt;location /&lt;/code&gt;段前面再添加一些匹配到这些静态文件的段，让它找到对应的文件。这里就不再赘述。&lt;/p&gt;

&lt;h2 id=&#34;命名空间怎么办&#34;&gt;命名空间怎么办？&lt;/h2&gt;

&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;新时代的我们当然想用命名空间了，起码我是不想写那么长的类名。&lt;/p&gt;

&lt;p&gt;可喜的是Yaf只需要一条配置就可以爽快的支持PSR-4规范的命名空间。
可惜的是Yaf的这条配置是全局的，如果你的应用和别的应用公用PHP配置，而别人不用，那就没办法了。&lt;/p&gt;

&lt;p&gt;这条配置就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;;php.ini
yaf.use_namespace=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;

&lt;p&gt;我们都需要Http类吧，假设我写个HttpFoundation\Request类，可以在&lt;code&gt;library&lt;/code&gt;下新建&lt;code&gt;HttpFoundation&lt;/code&gt;目录，在其中新建&lt;code&gt;Request.php&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// HttpFoundation/Request.php
namespace HttpFoundation;

class Request
{
	public function get()
	{
		echo &amp;quot;I am going to send a GET request&amp;quot;;
		exit;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就注册了一个&lt;code&gt;HttpFoundation\Request&lt;/code&gt;类，在Controller中使用它只需要这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Yaf\Controller_Abstract;
use HttpFoundation\Request;

class FooController extends Controller_Abstract
{
	public function barAction()
	{
		$request = new Request();
		$request-&amp;gt;get();
		exit;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;再远一点&#34;&gt;再远一点？&lt;/h3&gt;

&lt;p&gt;是不是感受到了鸟哥的高瞻远瞩？其实我们还可以想的更多一点，既然可以自己写个HttpFoundation包了，你有没有想到Composer？因为多数时候这些基础类库都有现成的，用Composer安装就好，既然Yaf已经提供了性能好于autoloader的Yaf_Loader，何乐而不用呢？你甚至都可以引入第三方的ORM，比如Doctrine，第三方模板引擎Twig——对，没错，我就是Symfony的粉丝。&lt;/p&gt;

&lt;h2 id=&#34;目录结构设置&#34;&gt;目录结构设置&lt;/h2&gt;

&lt;p&gt;读一下Yaf源代码就特别清晰的看到默认的目录设置了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── application
│   ├── Bootstrap.php
│   ├── controllers
│   │   ├── Another.php
│   │   └── Index.php
│   ├── library
│   │   ├── Helper
│   │   └── HttpFoundation
│   │       └── Request.php
│   ├── models
│   ├── modules
│   │   └── Foo
│   │       └── controllers
│   │           └── Foo.php
│   ├── plugins
│   └── views
├── conf
│   ├── app.ini
│   └── db.ini
└── public
    └── index.php
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;application&lt;/p&gt;

&lt;p&gt;这是应用的主目录。&lt;/p&gt;

&lt;p&gt;想让应用能最简单的跑起来，得有Controller，也就是controllers目录，这里面放的是IndexModule的东西。&lt;/p&gt;

&lt;p&gt;底层用到的一些类库，放在library里。&lt;/p&gt;

&lt;p&gt;数据库操作放在models里。&lt;/p&gt;

&lt;p&gt;多模块放在modules里。像上面的树图里一样，每个module里还有相应的Controller。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;conf&lt;/p&gt;

&lt;p&gt;存放配置文件。&lt;/p&gt;

&lt;p&gt;我看多数时候是把它放在application里的，但我更倾向于把它放在和application同级目录下。其中的app.ini是Yaf框架的基础配置，里面需要包含Yaf的『唯一一个』必选配置项&lt;code&gt;application.directory&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;public&lt;/p&gt;

&lt;p&gt;存放index.php和静态文件。&lt;/p&gt;

&lt;p&gt;这里是用户可以直接访问的文件。静态文件放在这里最合适不过了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;插件的使用&#34;&gt;插件的使用&lt;/h2&gt;

&lt;p&gt;应用上线后Nginx的配置就不太好改了，但我们可以随意修改代码啊，所以如果需要对路由规则做一些修改，可以写个插件。下面以Route插件为例，介绍插件的使用。&lt;/p&gt;

&lt;h3 id=&#34;新建插件&#34;&gt;新建插件&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;application/plugins&lt;/code&gt;目录里新建&lt;code&gt;Route.php&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Yaf\Plugin_Abstract;
use Yaf\Request_Abstract;
use Yaf\Response_Abstract;

class RoutePlugin extends Plugin_Abstract
{
	public function routerStartup(Request_Abstract $request, Response_Abstract $response)
	{
		// some logic here
		$request-&amp;gt;setModule(&#39;foo&#39;);
		$request-&amp;gt;setController(&#39;bar&#39;);
		$request-&amp;gt;setAction(&#39;doge&#39;);
	}
	....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;注册插件&#34;&gt;注册插件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Bootstrap.php

use Yaf\Bootstrap_Abstract;
use Yaf\Dispatcher;

class Bootstrap extends Bootstrap_Abstract
{
	public function _initPlugin(Dispatcher $dispatcher)
	{
		$dispatcher-&amp;gt;regiserPlugin(new RouterPlugin());
	}
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候你可以试一下，所有请求都会被路由到FooModule/BarController/dogeAction了。&lt;/p&gt;

&lt;h2 id=&#34;单controller多action配置&#34;&gt;单Controller多Action配置&lt;/h2&gt;

&lt;p&gt;这个问题困扰我最久，最不理解的就是为什么要一个Controller里面只有一个indexAction，然后其他的路由还需要传一个action参数来自己做路由。其实默认的Yaf_Route_Static自己就支持这种写法的。只要保证&lt;code&gt;application.dispatcher.defaultRoute&lt;/code&gt;的值为空或&lt;code&gt;static&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;多模块配置&#34;&gt;多模块配置&lt;/h2&gt;

&lt;p&gt;在目录结构设置一节中已经说过怎么创建多模块。那么多模块有什么用呢？&lt;/p&gt;

&lt;p&gt;假设我们要做一个后台，不同模块是需要不同的访问权限的，该怎么办？我的想法是这样，做一个权限控制的plugin，先检查用户身份，然后&lt;code&gt;$request-&amp;gt;getModule()&lt;/code&gt;，如果要访问的是该用户不具有权限的模块，就给跳到一个403页。&lt;/p&gt;

&lt;h2 id=&#34;配置分节&#34;&gt;配置分节&lt;/h2&gt;

&lt;p&gt;假设这样一个场景，你线上和线下资源配置肯定是不一样的，但又有些是一样的，怎么办？还以&lt;code&gt;db.ini&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[db]
adapter=pdo_mysql

[prod:db]
host=&amp;quot;DB_HOST&amp;quot;
port=&amp;quot;DB_PORT&amp;quot;

[dev:prod]
host=&amp;quot;DB_HOST_DEV&amp;quot;
port=&amp;quot;DB_PORT_DEV&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况下可以写一个工具类，因为我觉得这个Yaf\Config\Ini提供的API并不太好用，先要初始化才能用。我做一层封装，不成想竟然发现了很方便的从生产环境/开发环境/测试环境的方法。工具类如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
namespace Your\Name\Space;
use Yaf\Config\Ini;

class Conf
{
    public static function get($key)
    {
        $filename = PATH/TO/CONF . &#39;/&#39; . explode(&#39;.&#39;, $key) . &#39;.ini&#39;;

        if (is_file($filename) &amp;amp;&amp;amp; is_readable($filename)) {
            $config = (new Ini($filename, ENV))-&amp;gt;get($key);
            if (is_a($config, &#39;Yaf\Config\Ini&#39;)) {
                $config = $config-&amp;gt;toArray();
            }
        } else {
            $config = null;
        }

        return $config;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个工具类的作用是支持&lt;code&gt;Your\Name\Space\Conf::get(&#39;foo.bar.good&#39;);&lt;/code&gt;的方式取值。如果配置文件是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[test]
foo.bar.good = &#39;good foo&#39;
foo.bar.better = &#39;better foo&#39;

[prod:test]
foo.bar.better = &#39;best foo&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那用&lt;code&gt;Your\Name\Space\Conf::get(&#39;foo.bar&#39;);&lt;/code&gt;取出的就是包含&lt;code&gt;good&lt;/code&gt;和&lt;code&gt;better&lt;/code&gt;的一个数组，如果是&lt;code&gt;Your\Name\Space\Conf::get(&#39;foo.bar.good&#39;);&lt;/code&gt;这样，就是&lt;code&gt;good foo&lt;/code&gt;这个字符串。&lt;/p&gt;

&lt;p&gt;重点是对生产环境的切换。注意实例化&lt;code&gt;Ini&lt;/code&gt;类的时候的那个&lt;code&gt;ENV&lt;/code&gt;变量，你可以在&lt;code&gt;/public/index.php&lt;/code&gt;中&lt;code&gt;define&lt;/code&gt;这个常量，然后又从一个公共的工具类中取出配置，所以只需要在修改&lt;code&gt;index.php&lt;/code&gt;里面的&lt;code&gt;ENV&lt;/code&gt;的定义，就可以方便的在各种环境之间切换了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
