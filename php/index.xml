<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phps on Me &amp; Web</title>
    <link>http://lovelock.coding.me/php/index.xml</link>
    <description>Recent content in Phps on Me &amp; Web</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2013-2016 Frost Wong. All rights reserved.</copyright>
    <lastBuildDate>Tue, 17 Jan 2017 15:48:42 +0800</lastBuildDate>
    <atom:link href="/php/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>没有参数的函数（区别于类的方法）</title>
      <link>http://lovelock.coding.me/php/internals/a-function-without-arguments/</link>
      <pubDate>Tue, 17 Jan 2017 15:48:42 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/internals/a-function-without-arguments/</guid>
      <description>&lt;p&gt;距离上一次写PHP扩展相关的内容已经很久很久了，这两天又想着写一个真正意义上的扩展了，所以又要重新学习了。&lt;/p&gt;

&lt;p&gt;先从写一个最简单的函数说起，从我现在的理解来说这个函数是全局的。比如我要实现一个最简单的&lt;code&gt;helloworld&lt;/code&gt;函数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里说一个小插曲，最后不要用dash(-)作为扩展名字的一部分，会出现乱七八糟的麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图所示，&lt;img src=&#34;https://ww4.sinaimg.cn/large/006tNc79ly1fbtoytl1g7j31ks0jswjf.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是&lt;code&gt;PHP_FUNCTION(helloworld)&lt;/code&gt;这段需要放在&lt;code&gt;const&lt;/code&gt;这段前面，因为相当于前面是定义了&lt;code&gt;helloworld&lt;/code&gt;这个函数名，后面是把它注册到『可用函数列表』中，如果都没有定义，怎么注册呢，对吧？&lt;/p&gt;

&lt;p&gt;至于编译的细节，请看我之前的文章。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——扩展的骨架</title>
      <link>http://lovelock.coding.me/php/internals/create-skeleton-of-extension/</link>
      <pubDate>Sat, 09 Apr 2016 22:04:18 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/internals/create-skeleton-of-extension/</guid>
      <description>

&lt;p&gt;前面啰嗦了这么多读者都要没有兴趣了。从现在起要真正开始PHP扩展开发阶段了。&lt;/p&gt;

&lt;p&gt;首先来生成扩展的骨架。所谓骨架就是一个扩展需要的基本文件了。&lt;/p&gt;

&lt;h2 id=&#34;获取php源码&#34;&gt;获取PHP源码&lt;/h2&gt;

&lt;p&gt;截至目前，PHP最新源码是7.0.5。&lt;a href=&#34;http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  projects wget http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror -O php705.tar.bz2
--2016-04-09 10:18:39--  http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror
Resolving cn2.php.net (cn2.php.net)... 202.108.35.194, 202.108.35.235, 202.108.35.237, ...
Connecting to cn2.php.net (cn2.php.net)|202.108.35.194|:80... connected.
HTTP request sent, awaiting response... 302 Found
Location: http://cn2.php.net/distributions/php-7.0.5.tar.bz2 [following]
--2016-04-09 10:18:39--  http://cn2.php.net/distributions/php-7.0.5.tar.bz2
Reusing existing connection to cn2.php.net:80.
HTTP request sent, awaiting response... 200 OK
Length: 14086522 (13M) [application/octet-stream]
Saving to: ‘php705.tar.bz2’

php705.tar.bz2                             100%[=======================================================================================&amp;gt;]  13.43M  4.49MB/s    in 3.0s

2016-04-09 10:18:42 (4.49 MB/s) - ‘php705.tar.bz2’ saved [14086522/14086522]

➜  projects md5sum php705.tar.bz2
b15e6836babcbf0aa446678ee38f896b  php705.tar.bz2
➜  projects echo b15e6836babcbf0aa446678ee38f896b
b15e6836babcbf0aa446678ee38f896b
➜  projects tar xjf php705.tar.bz2
➜  projects cd php-7.0.5/ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于来到了正题了。我现在也终于明白鸟哥为啥费劲写个生成Yaf最小化应用的脚本了，就是从写扩展的经历中得来的，既然可以帮用户做的更多，那就帮一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext ./ext_skel --extname=hylog
Creating directory hylog
Creating basic files: config.m4 config.w32 .gitignore hylog.c php_hylog.h CREDITS EXPERIMENTAL tests/001.phpt hylog.php [done].

To use your new extension, you will have to execute the following steps:

1.  $ cd ..
2.  $ vi ext/hylog/config.m4
3.  $ ./buildconf
4.  $ ./configure --[with|enable]-hylog
5.  $ make
6.  $ ./sapi/cli/php -f ext/hylog/hylog.php
7.  $ vi ext/hylog/hylog.c
8.  $ make

Repeat steps 3-6 until you are satisfied with ext/hylog/config.m4 and
step 6 confirms that your module is compiled into PHP. Then, start writing
code and repeat the last two steps as often as necessary.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，&lt;code&gt;ext_skel&lt;/code&gt;就帮我们生成了一个名为&lt;code&gt;hylog&lt;/code&gt;的扩展框架。&lt;/p&gt;

&lt;p&gt;下面要介绍一下安装扩展的两种方式了，一种是直接编译进PHP，一种是接下来我们要讨论的这种，即动态加载的扩展。&lt;/p&gt;

&lt;p&gt;什么是直接编译进PHP呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext cd hylog
➜  hylog ls
config.m4  config.w32  CREDITS  EXPERIMENTAL  hylog.c  hylog.php  php_hylog.h  tests
➜  hylog vim config.m4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会看到这样的几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl If your extension references something external, use with:

dnl PHP_ARG_WITH(hylog, for hylog support,
dnl Make sure that the comment is aligned:
dnl [  --with-hylog             Include hylog support])

dnl Otherwise use enable:

dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;dnl&lt;/code&gt;是注释，主要看&lt;code&gt;--with-hylog&lt;/code&gt;和&lt;code&gt;--enable-hylog&lt;/code&gt;。假定你来看本文，你一定自己编译过PHP了，如果没有，那先去整一遍再回来看吧：）
是这样的，我们在编译PHP的时候经常会碰到类似这种&lt;code&gt;--with[out]-blah=/path/to/foo&lt;/code&gt;或者&lt;code&gt;--enable-blah&lt;/code&gt;或者&lt;code&gt;--disable-blah&lt;/code&gt;的选项吧。其实对编写扩展的我们来说，这两种都是可行的，并没有本质上的区别，只是一般用&lt;code&gt;--with&lt;/code&gt;会带个路径，告诉PHP这个扩展依赖的外部库的路径，而&lt;code&gt;--enable&lt;/code&gt;则表示该扩展是独立的，或者依赖的库在默认的搜索路径内。&lt;/p&gt;

&lt;p&gt;那和我们说的两种安装方式有什么关系呢？不如我们就来真的安装一下看看效果吧。&lt;/p&gt;

&lt;p&gt;看上面的注释，我们知道了需要把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
[  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于是喜欢用&lt;code&gt;--enable&lt;/code&gt;还是喜欢用&lt;code&gt;--with&lt;/code&gt;看个人喜好了，因为本例中并没有用到外部依赖，所以用&lt;code&gt;--enable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;提醒一下，改完之后最好把当前的这个状态保存下来——创建一个git工作目录就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git init
Initialized empty Git repository in /home/frost/projects/php-7.0.5/ext/hylog/.git/
➜  hylog git:(master) ✗ gst
On branch master

Initial commit

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	.gitignore
	CREDITS
	EXPERIMENTAL
	config.m4
	config.w32
	hylog.c
	hylog.php
	php_hylog.h
	tests/

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
➜  hylog git:(master) ✗ ga .
➜  hylog git:(master) ✗ gc -m &#39;init hylog&#39;
[master (root-commit) 58e5e4a] init hylog
 Committer: frost &amp;lt;frost@debian.unixera.com&amp;gt;
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 9 files changed, 409 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 CREDITS
 create mode 100644 EXPERIMENTAL
 create mode 100644 config.m4
 create mode 100644 config.w32
 create mode 100644 hylog.c
 create mode 100644 hylog.php
 create mode 100644 php_hylog.h
 create mode 100644 tests/001.phpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么要这么做呢？其实主要是想让这个目录干净，因为待会儿执行了一些命令之后会生成很多文件，如果你想清除这些文件就变得很麻烦。但现在我只把这些文件&lt;code&gt;commit&lt;/code&gt;了，待会儿生成文件后，如果我想删除，就可以用&lt;code&gt;git clean -df&lt;/code&gt;，立即回到现在的状态。但关于&lt;code&gt;git&lt;/code&gt;的操作，那就是另外一回事了（强烈推荐&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;廖雪峰的git教程&lt;/a&gt;)。&lt;/p&gt;

&lt;h3 id=&#34;编译进php&#34;&gt;编译进PHP&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重新生成配置文件&lt;/p&gt;

&lt;p&gt;注意其中的&lt;code&gt;./buildconf --force&lt;/code&gt;，之所以带&lt;code&gt;--force&lt;/code&gt;是因为我们是在正式版的PHP源码中进行操作的，正常情况下使用这种方式编译的都是内建扩展，例如&lt;code&gt;PDO&lt;/code&gt;这种，是PHP官方团队开发的，所以你非要用这种方式编译的话，就强制一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) cd ..
➜  ext cd ..
➜  php-7.0.5 ./buildconf --force
Forcing buildconf
Removing configure caches
buildconf: checking installation...
buildconf: autoconf version 2.69 (ok)
rebuilding aclocal.m4
rebuilding configure
rebuilding main/php_config.h.in
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找变化&lt;/p&gt;

&lt;p&gt;刚刚的操作背后发生了什么呢？注意&lt;code&gt;rebuilding&lt;/code&gt;的三行，那我们就挨个看看。分别在三个文件中搜索&lt;code&gt;hylog&lt;/code&gt;关键字吧。
在&lt;code&gt;aclocal.m4&lt;/code&gt;中未找到变化。
在&lt;code&gt;configure&lt;/code&gt;中有大量变化，稍后介绍能看到的变化。
在&lt;code&gt;main/php_config.h.in&lt;/code&gt;中，增加了两行，用来取消&lt;code&gt;COMPILE_DL_HYLOG&lt;/code&gt;的定义，表示该扩展不是动态加载。&lt;/p&gt;

&lt;p&gt;这时检查一下&lt;code&gt;configure --help&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --help | grep hylog
  --enable-hylog           Enable hylog support
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诶，有点眼熟对不对？就是刚才在&lt;code&gt;ext/hylog/config.m4&lt;/code&gt;中取消注释的内容。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编译PHP&lt;/p&gt;

&lt;p&gt;既然要把它编译进来，那就加上&lt;code&gt;--enable-hylog&lt;/code&gt;吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --enable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看已安装的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 php -v
PHP 7.0.5 (cli) (built: Apr  9 2016 11:08:08) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
➜  php-7.0.5 php -m
[PHP Modules]
Core
ctype
date
dom
fileinfo
filter
hash
hylog
iconv
json
libxml
pcre
PDO
pdo_sqlite
Phar
posix
Reflection
session
SimpleXML
SPL
sqlite3
standard
tokenizer
xml
xmlreader
xmlwriter
    
[Zend Modules]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看到我们新创建的扩展已经编译进PHP了——虽然它没有任何功能。可以再到&lt;code&gt;/usr/local/lib/php/extensions/no-debug-non-zts-20151012&lt;/code&gt;中验证一下是不是真的没有&lt;code&gt;hylog.so&lt;/code&gt;存在。&lt;/p&gt;

&lt;p&gt;所以如果不想用它了怎么办呢？你当然可以选择无视它，但最好还是卸载了吧，卸载的方法也很简单，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --disable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来就是三行，其实要用很长时间，所以，像我们这样的第三方扩展开发者还是不要用这种方式比较好。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;动态加载&#34;&gt;动态加载&lt;/h3&gt;

&lt;p&gt;动态加载方式是把每个扩展编译成一个单独的&lt;code&gt;.so&lt;/code&gt;文件，然后在&lt;code&gt;php.ini&lt;/code&gt;中加上&lt;code&gt;extension=hylog.so&lt;/code&gt;，如果有配置就再加上一些配置。CLI的话就直接生效了，FPM环境下就要重启一下FPM了。我们这里只讨论CLI模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方扩展安装的一般流程&lt;/p&gt;

&lt;p&gt;还记得我刚刚提到的执行某些命令后会生成很多文件吗？就是这里了。如果你还没有用&lt;code&gt;git&lt;/code&gt;，我劝你现在用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) phpize
Configuring for:
PHP Api Version:         20151012
Zend Module Api No:      20151012
Zend Extension Api No:   320151012
➜  hylog git:(master) ✗ ./configure
➜  hylog git:(master) ✗ make
➜  hylog git:(master) ✗ sudo make install
Installing shared extensions:     /usr/local/lib/php/extensions/no-debug-non-zts-20151012/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，到这里已经看到在独立编译动态扩展时，生成的&lt;code&gt;.so&lt;/code&gt;文件是放在了这个目录下的。这时动态的好处就体现出来了。文件有了，至于你想不想用，只需要修改&lt;code&gt;php.ini&lt;/code&gt;即可，不用任何重新编译。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装和卸载扩展&lt;/p&gt;

&lt;p&gt;前面说了，如果需要该扩展，编辑&lt;code&gt;/usr/local/lib/php.ini&lt;/code&gt;，在最下面添加（安装）或删除（卸载）一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;extension=hylog.so
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调试&lt;/p&gt;

&lt;p&gt;我可不敢保证代码一次就能成功，调试的时候要多次执行以上三个命令，所以可以创建一个&lt;code&gt;rebuild.sh&lt;/code&gt;脚本，运行脚本重新编译并安装最新的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最好把它加入到&lt;code&gt;git&lt;/code&gt;工作目录中。&lt;/p&gt;

&lt;p&gt;扩展的安装就这些，下一节介绍PHP变量的基本类型。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——用PHP实现类的原型</title>
      <link>http://lovelock.coding.me/php/internals/class-prototype-in-php/</link>
      <pubDate>Sat, 09 Apr 2016 21:55:00 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/internals/class-prototype-in-php/</guid>
      <description>&lt;p&gt;在编写之前先用PHP实现这个类的原型吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace Hylog;

use \DateTime;

class Hylog
{
    const HYLOG_VERSION = &amp;quot;0.1.0&amp;quot;;

    const EMERGENCY = &#39;EMERGENCY&#39;;
    const ALERT     = &#39;ALERT&#39;;
    const CRITICAL  = &#39;CRITICAL&#39;;
    const ERROR     = &#39;ERROR&#39;;
    const WARNING   = &#39;WARNING&#39;;
    const NOTICE    = &#39;NOTICE&#39;;
    const INFO      = &#39;INFO&#39;;
    const DEBUG     = &#39;DEBUG&#39;;

    private static $_instance;

    private $_basePath;
    private $_sliceLogByHour;

    public function log($level, $message, $context = array())
    {
        $line = $this-&amp;gt;interpolate($message, $context);

        $datetime         = new DateTime();
        $timestamp        = $datetime-&amp;gt;getTimestamp();
        $formatedDatetime = $datetime-&amp;gt;format(DateTime::ATOM);

        $line = $timestamp . &amp;quot;\t|\t&amp;quot; . $formatedDatetime . &amp;quot;\t|\t&amp;quot; . $line;

        $this-&amp;gt;output($level, $line);
    }

    public function emergency($message, $context = array())
    {
        $this-&amp;gt;log(self::EMERGENCY, $message, $context);
    }

    public function alert($message, $context = array())
    {
        $this-&amp;gt;log(self::ALERT, $message, $context);
    }

    public function critical($message, $context = array())
    {
        $this-&amp;gt;log(self::CRITICAL, $message, $context);
    }

    public function error($message, $context = array())
    {
        $this-&amp;gt;log(self::ERROR, $message, $context);
    }

    public function warning($message, $context = array())
    {
        $this-&amp;gt;log(self::WARING, $message, $context);
    }

    public function notice($message, $context = array())
    {
        $this-&amp;gt;log(self::NOTICE, $message, $context);
    }

    public function info($message, $context = array())
    {
        $this-&amp;gt;log(self::INFO, $message, $context);
    }

    public function debug($message, $context = array())
    {
        $this-&amp;gt;log(self::DEBUG, $message, $context);
    }

    public static function getInstance() : object
    {
        if (!isset(self::$_instance)) {
            self::$_instance = new static();
        }

        return self::$_instance;
    }

    public function getVersion()
    {
        return self::HYLOG_VERSION;
    }

    public function setBasePath($path)
    {
        $this-&amp;gt;_basePath = $path;
    }

    public function getBasePath() : string
    {
        return $this-&amp;gt;_basePath;
    }

    public function setSliceByHour($bool)
    {
        $this-&amp;gt;_sliceLogByHour = $bool;
    }

    public function getSliceByHour() : bool
    {
        return $this-&amp;gt;_sliceLogByHour;
    }

    private function output($level, $message)
    {
        $logFile = $this-&amp;gt;getLogFile($level);

        error_log($message . PHP_EOL, 3, $logFile);
    }

    private function getLogFile($level) : string
    {
        $cHour = date(&#39;ymdH&#39;);
        $cDay  = date(&#39;ymd&#39;);

        if ($this-&amp;gt;_sliceLogByHour) {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cHour . &#39;.log&#39;;
        } else {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cDay . &#39;.log&#39;;
        }
    }

    private function interpolate($message, $context = array())
    {
        foreach ($context as $key =&amp;gt; $val) {
            $replace[&#39;{&#39; . $key . &#39;}&#39;] = $val;
        }

        return strtr($message, $replace);
    }

    private function __construct()
    {
        $this-&amp;gt;_basePath = &#39;/tmp/log&#39;;

        if (!is_dir($this-&amp;gt;_basePath)) {
            mkdir($this-&amp;gt;_basePath, 0700, true);
        } else {
            chmod($this-&amp;gt;_basePath, 0700);
        }

        $this-&amp;gt;_sliceLogByHour = true;
    }

    private function __clone()
    {
    }

    private function __wakeup()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——目标和计划</title>
      <link>http://lovelock.coding.me/php/internals/schedules/</link>
      <pubDate>Sat, 09 Apr 2016 21:13:28 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/internals/schedules/</guid>
      <description>

&lt;p&gt;好了，现在来整理一下我们要做的工作。&lt;/p&gt;

&lt;h2 id=&#34;功能目标&#34;&gt;功能目标&lt;/h2&gt;

&lt;p&gt;既然是要做一个记日志的扩展，那当然就避免不了两个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;格式化日志流&lt;/li&gt;
&lt;li&gt;将日志流推送到特定目标（通常是写入文件）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个是最核心的功能，其他的都是辅助。但辅助也可以很贴心，所以我设计了以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽可能多的从扩展层面获取共用的信息，比如时间、客户端IP、当前机器的IP等（这里涉及&lt;strong&gt;超全局变量&lt;/strong&gt;的获取）&lt;/li&gt;
&lt;li&gt;设计尽量简单的默认规则，既可以开箱即用，又可以随心配置&lt;/li&gt;
&lt;li&gt;遵守&lt;a href=&#34;http://www.php-fig.org/psr/psr-3/&#34;&gt;PSR-3&lt;/a&gt;规范&lt;/li&gt;
&lt;li&gt;命名空间和传统写法的兼容(鸟哥的Yaf是教科书）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个需要考虑的问题是高并发场景下的文件写入丢失问题，我觉得以我目前的水平是无法解决这个问题的，那没关系，PHP内置的已经有强大的&lt;code&gt;error_log&lt;/code&gt;方法了，它可以保证这点，用它就可以。喂等等，那既然已经有了&lt;code&gt;error_log&lt;/code&gt;，我干嘛还要做这个呢？&lt;/p&gt;

&lt;p&gt;因为它不够灵活。&lt;/p&gt;

&lt;p&gt;我们通常的做法是封装&lt;code&gt;error_log&lt;/code&gt;方法，填充默认参数、格式化、写入文件等，&lt;code&gt;error_log&lt;/code&gt;方法本身是很快的，但挡不住我们添加的这些代码的消耗也很大，因为写日志是个非常频繁的操作，所以一个极小的性能损失积累下来都可能影响很大。&lt;/p&gt;

&lt;h2 id=&#34;取名&#34;&gt;取名&lt;/h2&gt;

&lt;p&gt;既然用C写，那就是奔着高性能去的，High Performance PHP Log，叫Hilog貌似就可以，但为了致敬鸟哥，把i换成y好了：）所以叫Hylog。&lt;/p&gt;

&lt;h2 id=&#34;类的设计&#34;&gt;类的设计&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;拥有PRS-3规定的8个level作为常量&lt;/li&gt;
&lt;li&gt;对应8个方法，分别写到不同的文件&lt;/li&gt;
&lt;li&gt;一个log方法比上述8个方法多个level参数，上述8个函数实际是调用这个方法记日志的&lt;/li&gt;
&lt;li&gt;格式化日志的方法&lt;/li&gt;
&lt;li&gt;数组插值的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;依赖关系&#34;&gt;依赖关系&lt;/h2&gt;

&lt;p&gt;依赖PHP内置函数&lt;code&gt;error_log&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用PHP生成器和迭代器</title>
      <link>http://lovelock.coding.me/php/php-generator-and-iterator/</link>
      <pubDate>Tue, 05 Apr 2016 12:05:46 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/php-generator-and-iterator/</guid>
      <description>

&lt;p&gt;从开始写PHP就知道迭代器这个东西，当时师傅告诉我用的挺少的，需要的时候再看也不晚，于是就没有放在意上。但他还说这其实也是区分高手和菜鸟的一个标志，那我还是研究一下好了：）&lt;/p&gt;

&lt;p&gt;PHP程序员都知道我们最经常用的可能就是&lt;code&gt;foreach&lt;/code&gt;这个大杀器了。得益于我们&lt;strong&gt;万能的数组&lt;/strong&gt;，所以这个大杀器在多数场合都是可以直接用的，只要输入元素是数组类型即可——事实上并不是如此，&lt;code&gt;foreach&lt;/code&gt;能遍历数组并不是因为它是数组，而是因为数组&lt;code&gt;implements&lt;/code&gt;了&lt;code&gt;Iterator&lt;/code&gt;接口。说白了就是只要告诉&lt;code&gt;foreach&lt;/code&gt;遍历的规则，它就可以执行遍历，而和是否数组无关。&lt;/p&gt;

&lt;h3 id=&#34;iterator&#34;&gt;Iterator&lt;/h3&gt;

&lt;h4 id=&#34;解析&#34;&gt;解析&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;接口定义了5个方法，如果一个类要实现&lt;code&gt;Iterator&lt;/code&gt;接口，当然就要实现这一套方法了。&lt;code&gt;Iterator&lt;/code&gt;的原型如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Interface Iterator
{
	abstract public function current() : mixed;
	abstract public function key() : scalar;
	abstract public function next() : void;
	abstract public function rewind() : void;
	abstract public function valid() : boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我在方法后面按照PHP7的新语法加了个返回值类型，其实这样写是不对的，但可以表明意思啦：）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细说一下这几个方法要做的事情。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;current()&lt;/p&gt;

&lt;p&gt;返回当前位置的&lt;strong&gt;值&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;key()&lt;/p&gt;

&lt;p&gt;返回当前位置的&lt;strong&gt;键&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;next()&lt;/p&gt;

&lt;p&gt;当前位置的&lt;strong&gt;键&lt;/strong&gt;加1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rewind()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;键&lt;/strong&gt;回到第一个位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;valid()&lt;/p&gt;

&lt;p&gt;返回当前的&lt;strong&gt;键&lt;/strong&gt;是否是有意义的。如是否是&lt;code&gt;false&lt;/code&gt;/&lt;code&gt;NULL&lt;/code&gt;等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;

&lt;p&gt;还是来具体写个例子理解一下吧。通常写这种例子的作者都会举一个类，它的一个属性是个数组，然后实现&lt;code&gt;Iterator&lt;/code&gt;的5个方法，来让这个类可以使用&lt;code&gt;foreach&lt;/code&gt;，这个例子没意思，因为数组本身就带&lt;code&gt;current&lt;/code&gt;、&lt;code&gt;key&lt;/code&gt;这些方法。让我来举一个&lt;code&gt;pdo_mysql&lt;/code&gt;从数据库中取数据的例子吧。&lt;/p&gt;

&lt;p&gt;从数据库取出一一个数组，数组中的元素是&lt;code&gt;User&lt;/code&gt;类的实例，我们需要&lt;code&gt;Users&lt;/code&gt;类的方法，它又要有一些方法。所以，就产生了这样的用法了。这个例子可能有些牵强，但起码描述了一个使用场景，比单纯的迭代一个类的类型为数组的属性要有意义。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git.coding.net/lovelock/iterator_example.git&#34;&gt;代码地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generator&#34;&gt;Generator&lt;/h3&gt;

&lt;p&gt;只有真正理解了&lt;code&gt;Iterator&lt;/code&gt;才能再来谈&lt;code&gt;Generator&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还是举例来说，前面已经说了一个比较复杂的例子，这里为了说明二者的区别，举个简单的例子。&lt;/p&gt;

&lt;p&gt;假定有一个日志文件，1000000行吧，很大了？或许吧。现在我们要遍历这个文件，找到我们需要的东西。如果使用&lt;code&gt;Iterator&lt;/code&gt;，可能需要这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class LinesIterator implements Iterator
{
	private $_fp;
	private $_currentLine;
	private $_lineNum;

	public function __construct($filename)
	{
		$this-&amp;gt;_fp = fopen($filename, &#39;r&#39;);
		$this-&amp;gt;_lineNum = 0;
	}

	public function current()
	{
		$this-&amp;gt;_currentLine = fgets($this-&amp;gt;_fp);
		return $this-&amp;gt;_currentLine;
	}

	public function key()
	{
		return $this-&amp;gt;_lineNum;
	}

	public function valid()
	{
		return $this-&amp;gt;_currentLine === false;
	}

	public function next()
	{
		fgets($this-&amp;gt;_fp);
		$this-&amp;gt;_lineNum++;
	}

	public function rewind()
	{
	}

	public function __destruct()
	{
		fclose($this-&amp;gt;_fp);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要遍历文件时，可以这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$file = new LinesIterator(&#39;file&#39;);

foreach ($file-&amp;gt;current() as $line) {
	echo $line;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这没有问题，但也太复杂了吧！！！重点是即使我实现了这些，但还是无法随便定位到某一行（这需要&lt;code&gt;fseek&lt;/code&gt;）。所以这种场景下，&lt;code&gt;Generator&lt;/code&gt;出现了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function getLine($fileName)
{
	$fp = fopen($fileName, &#39;r&#39;);	

	while ($line = fgets($fp) !== false) {
		yield $line;
	}

	fclose($fp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就简明多了。&lt;code&gt;Generator&lt;/code&gt;的标志就是&lt;code&gt;yield&lt;/code&gt;，这点在所有编程语言里都一样。&lt;/p&gt;

&lt;p&gt;正常如果在用&lt;code&gt;yield&lt;/code&gt;的地方用了&lt;code&gt;return&lt;/code&gt;，那么代码执行到这里就结束了，下次再执行这个函数时，还是从头开始，我们永远得不到文件的第二行。那么怎么办呢？我的理解是&lt;code&gt;Generator&lt;/code&gt;把这行内容返回的同时，也把文件句柄所在的指针向后移动了一个单位，下次再次执行该函数时，就会从上次的位置继续执行。&lt;/p&gt;

&lt;p&gt;这个函数的功能和上面那个类的效果完全相同。&lt;/p&gt;

&lt;p&gt;还有一点要提一下，&lt;code&gt;Generator&lt;/code&gt;通常用来处理文件特别大的情况，比如上面这样，文件太大，如果直接用&lt;code&gt;file&lt;/code&gt;读进来保存成为一个数组，很可能就会报错。而如果用&lt;code&gt;Generator&lt;/code&gt;就没有这个问题了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——背景介绍</title>
      <link>http://lovelock.coding.me/php/internals/introduction/</link>
      <pubDate>Mon, 04 Apr 2016 22:37:18 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/internals/introduction/</guid>
      <description>

&lt;p&gt;这段时间其实在看C语言，但看来看去也不知道学了这些知识用在哪里。作为一名PHP程序员，想要进阶，当然得懂PHP的运行原理。那么，编写扩展就成了认识PHP的必经之路。而PHP的扩展当然是用C写的，这样，也给自己刚刚学的C语言找到了练手的项目。&lt;/p&gt;

&lt;p&gt;那么写个什么项目好呢？最好简单一些，但也要能涵盖编写一个完整功能的扩展的方方面面。忘了在哪里看到了&lt;a href=&#34;https://github.com/Neeke/SeasLog&#34;&gt;SeasLog&lt;/a&gt;，感觉这个项目很符合我的期望，于是上它的issue列表里面找到了一个功能请求，作者还没有着手做，那我就顺手帮忙做了吧，前几天已经被作者合并了，让我的信心也倍增。所以，我决定自己也再写一个类似的东西，主要目的是通过做一个完整的项目，各个击破PHP扩展编写过程中的所有问题。&lt;/p&gt;

&lt;p&gt;言归正传，先列上参考文献列表好了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpinternalsbook.com/&#34;&gt;PHP internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/walu/phpbook&#34;&gt;PHP扩展开发及内核应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/en/internals2.php&#34;&gt;PHP at the core: A Hacker&amp;rsquo;s Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/yaf&#34;&gt;Yaf源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.php.net/downloads.php&#34;&gt;PHP源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/php7-internal&#34;&gt;Understanding PHP7 Internal articles&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;声明&#34;&gt;声明：&lt;/h2&gt;

&lt;p&gt;本系列所描述的PHP扩展相关知识大部分基于PHP 7.0.x，与PHP 5.x不完全兼容，因为列表里的前三个文献都是讲PHP5的，所以我在编写本文时也碰到了不少兼容性问题，都是通过看Yaf源码和PHP源码搞定兼容性的，我没有提到的地方还请在留言中指出。我当然也希望我的这份绵薄之力能帮助弥补目前PHP7相关文档严重不足的情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>seaslog 和 error_log性能大比拼</title>
      <link>http://lovelock.coding.me/php/log-bench/</link>
      <pubDate>Fri, 01 Apr 2016 16:33:19 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/log-bench/</guid>
      <description>

&lt;p&gt;今天花了点时间测试了开源项目&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;seaslog&lt;/a&gt;和PHP内置的error_log的性能。本文不涉及该扩展的安装和使用，如果对其不了解，可移步&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;项目的描述有语法问题&amp;rdquo;A effective &amp;hellip;&amp;ldquo;，我提醒了原作者，然而并没有被理会。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Intel&amp;reg; Xeon&amp;reg; CPU  E5520  @ 2.27GHz 8核&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;48G&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;7.0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nginx&lt;/td&gt;
&lt;td&gt;1.2.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试代码&#34;&gt;测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

error_log(&amp;quot;I am testing performance of error_log&amp;quot; . PHP_EOL, 3, __DIR__ . &#39;/error_log.log&#39;);
SeasLog::debug(&amp;quot;I am testing performance of seaslog&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果数据&#34;&gt;结果数据&lt;/h2&gt;

&lt;p&gt;每种方式测试5次，请求次数1000次，并发量分别是1, 10, 100, 1000。分别记录每次测试的QPS。&lt;/p&gt;

&lt;p&gt;1. error_log&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2430&lt;/td&gt;
&lt;td&gt;2579&lt;/td&gt;
&lt;td&gt;2685&lt;/td&gt;
&lt;td&gt;2484&lt;/td&gt;
&lt;td&gt;2622&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7303&lt;/td&gt;
&lt;td&gt;7844&lt;/td&gt;
&lt;td&gt;5892&lt;/td&gt;
&lt;td&gt;11739&lt;/td&gt;
&lt;td&gt;9002&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;11763&lt;/td&gt;
&lt;td&gt;6107&lt;/td&gt;
&lt;td&gt;6921&lt;/td&gt;
&lt;td&gt;9258&lt;/td&gt;
&lt;td&gt;11999&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;889&lt;/td&gt;
&lt;td&gt;883&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2. seaslog&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2147&lt;/td&gt;
&lt;td&gt;2071&lt;/td&gt;
&lt;td&gt;2130&lt;/td&gt;
&lt;td&gt;2123&lt;/td&gt;
&lt;td&gt;2039&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7415&lt;/td&gt;
&lt;td&gt;9438&lt;/td&gt;
&lt;td&gt;6901&lt;/td&gt;
&lt;td&gt;6445&lt;/td&gt;
&lt;td&gt;6047&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;7770&lt;/td&gt;
&lt;td&gt;9389&lt;/td&gt;
&lt;td&gt;6852&lt;/td&gt;
&lt;td&gt;5806&lt;/td&gt;
&lt;td&gt;6483&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;890&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;760&lt;/td&gt;
&lt;td&gt;322&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试结果图&#34;&gt;测试结果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/errorlog.png&#34; alt=&#34;error_log性能测试结果&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/seaslog.png&#34; alt=&#34;seaslog性能测试结果&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;error_log的性能总体优于seaslog，但并没有压倒性优势&lt;/li&gt;
&lt;li&gt;在并发较高时二者都出现急剧性能下降，程度相当。怀疑瓶颈已经不在写日志，而在Nginx的处理能力了（待验证）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;seaslog使用起来更简单，不需要多层封装&lt;/li&gt;
&lt;li&gt;error_log输出的格式比较单一，如果要加上日期、IP等信息，一定会引入很多PHP函数调用，导致性能损失。但seaslog在这方面就有很大的想象空间，在扩展中计算时间、获取IP、详细的debug信息都是可能的。不过现在并没有加入这些功能。&lt;/li&gt;
&lt;li&gt;seaslog提供了类似PDO的插值方式，使用起来更方便&lt;/li&gt;
&lt;li&gt;seaslog可以自定义配置多&lt;/li&gt;
&lt;li&gt;一个细节，error_log在type=3时并没有在message后面加上换行符，需要自行添加，也就是说每次都要有一个字符串拼接，这在seaslog中得到了改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我之前看到有人说seaslog的日期格式太固定，因此我fork了一份代码加上了配置日期格式的功能，作者到现在都没有合并进主干呢。而且我觉得现在这个功能有些简陋，比如我前面说的第2点，请求的一些基本信息如果从扩展层面直接取到，就不需要再在外层调用PHP函数或通过超全局变量获取了，既简化了外层使用的方式，又提高性能。但作者貌似也没有继续增加功能的意思，可能作者并不想在扩展层面做太复杂的事情，要保持这个项目的简单、纯粹。&lt;/p&gt;

&lt;p&gt;我还是自己再维护一份好了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>又一份Yaf文档——写给正在迷惑的你</title>
      <link>http://lovelock.coding.me/php/Yaf-yet-another-manual-for-human/</link>
      <pubDate>Mon, 01 Feb 2016 11:55:20 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/Yaf-yet-another-manual-for-human/</guid>
      <description>

&lt;p&gt;终于把困扰我很久的问题搞定了，好开心。趁着记忆还热乎，一定要把它记下来。&lt;/p&gt;

&lt;p&gt;前几天还和同事抱怨，用Yaf框架的人那么多，但我们身边竟然没有一个人对它的用法很清楚的。真是有些悲哀。几个同事都说鸟哥写的Yaf文档看不明白。&lt;/p&gt;

&lt;p&gt;言归正传，就我自己的学习过程来看，如果你要自己搭建一个Yaf环境，遇到的问题可能主要有以下这些：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置Nginx的rewrite规则&lt;/li&gt;
&lt;li&gt;命名空间怎么用&lt;/li&gt;
&lt;li&gt;目录结构设置&lt;/li&gt;
&lt;li&gt;插件的使用&lt;/li&gt;
&lt;li&gt;单Controller多Action配置&lt;/li&gt;
&lt;li&gt;多模块配置&lt;/li&gt;
&lt;li&gt;更多配置文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就这些问题一一给出解答。&lt;/p&gt;

&lt;h2 id=&#34;配置nginx的rewrite规则&#34;&gt;配置Nginx的rewrite规则&lt;/h2&gt;

&lt;p&gt;让我们直接忽略Apache和Lighttpd吧，默认大家都用Nginx。&lt;/p&gt;

&lt;h3 id=&#34;yaf路由规则&#34;&gt;Yaf路由规则&lt;/h3&gt;

&lt;p&gt;如果你看过官方文档，那4种路由规则我就不说了，只说最简单也是默认的&lt;code&gt;Yaf_Route_Static&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;读了Yaf源码的同学会发现，其实这个规则就是解析&lt;code&gt;request_uri&lt;/code&gt;，用&lt;code&gt;/&lt;/code&gt;把它分开，然后用每一部分去匹配Module/Controller/Action/Param。举个例子吧，假设PATH=/foo/bar/doge，更通俗一点，如果你的域名是&lt;code&gt;http://yaf.dev&lt;/code&gt;，那么这个例子中的完整URL就是&lt;code&gt;http://yaf.dev/foo/bar/doge&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;路由规则做了以下动作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;解析URL，得到PATH部分&lt;/li&gt;
&lt;li&gt;认为&lt;code&gt;foo&lt;/code&gt;是Module，去&lt;code&gt;application.modules&lt;/code&gt;配置中找&lt;code&gt;Foo&lt;/code&gt;（不区分大小写）&lt;/li&gt;
&lt;li&gt;如果找到了&lt;code&gt;modules/Foo&lt;/code&gt;，则继续认为&lt;code&gt;bar&lt;/code&gt;是Controller，查找&lt;code&gt;modules/Foo/BarController&lt;/code&gt;；没找到则会认为&lt;code&gt;foo&lt;/code&gt;是Controller，下面同4&lt;/li&gt;
&lt;li&gt;如果找到了&lt;code&gt;modules/Foo/BarController&lt;/code&gt;，则继续认为&lt;code&gt;doge&lt;/code&gt;是Action，查找&lt;code&gt;modules/Foo/BarController/dogeAction&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样是不是很清晰了？&lt;/p&gt;

&lt;h2 id=&#34;不要这样配&#34;&gt;不要这样配&lt;/h2&gt;

&lt;p&gt;老湿老湿，你不是要说Nginx的rewrite规则怎么配吗，怎么在这讲起了路由规则？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我是要告诉你不要听那些自作聪明的人(没错就是我)把rewrite规则配错!!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也就是说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rewrite ^/(.*)  /index.php/$1 last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是绝对正确的，不要看谁谁谁说这不对而写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rewrite ^/(.*)  /index.php?$1 last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这才是错误的。&lt;/p&gt;

&lt;p&gt;我的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen 80;

    root /var/www/yaf.ubuntu.com/public;

    index index.php index.html;

    server_name yaf.ubuntu.com;

    location = /favicon.ico {
        access_log off;
        error_log off;
        log_not_found off;
    }

    if (!-e $request_filename) {
        rewrite ^/(.*\.(js|ico|gif|jpg|png|css|bmp|html|xls)$) /public/$1 last;
        rewrite ^/(.*)  /index.php/$1 last;
    }

    location ~ \.php {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/usr/local/var/run/php-fpm-www.sock;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个配置主要是加上了对静态文件的支持，如果没有多出来的配置，你会经常在日志中看到找不到Favicon.ico.php找不到的500报错。&lt;/p&gt;

&lt;h2 id=&#34;fpm配置&#34;&gt;FPM配置&lt;/h2&gt;

&lt;p&gt;那好，路由规则明白了，rewrite规则好了，毕竟我是PHP脚本啊，得有FPM吧。通常来说，Nginx会给你一个默认的配置，以Debian为例，用apt安装的Nginx自带的default配置&lt;code&gt;location ~ \.php$&lt;/code&gt;段如下（已删除注释，我喜欢用unix socket，不服来打我啊）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ \.php$ {
	include snippets/fastcgi-php.conf;
	fastcgi_pass unix:/var/run/php7.0-fpm.sock;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样没问题，但也仅限于&lt;code&gt;http://yaf.dev/xxxx.php&lt;/code&gt;这种请求。别的都匹配不到啊，别忘了，你请求URL可不是这样的。&lt;/p&gt;

&lt;p&gt;所以，只要它是个请求，都要让它可以经过FPM。改成这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
	include snippets/fastcgi-php.conf;
	fastcgi_pass unix:/var/run/php7.0-fpm.sock;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，把这两部分保存一下，重启一下Nginx服务&lt;code&gt;sudo systemctl restart nginx&lt;/code&gt;，访问一下，哈，爽。&lt;/p&gt;

&lt;h3 id=&#34;静态文件怎么办&#34;&gt;静态文件怎么办？&lt;/h3&gt;

&lt;p&gt;这样配置，访问Action什么的是没问题了，但如果要访问这个域名下的静态文件，css/js啥的，就有问题了，这就需要在上面的&lt;code&gt;location /&lt;/code&gt;段前面再添加一些匹配到这些静态文件的段，让它找到对应的文件。这里就不再赘述。&lt;/p&gt;

&lt;h2 id=&#34;命名空间怎么办&#34;&gt;命名空间怎么办？&lt;/h2&gt;

&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;

&lt;p&gt;新时代的我们当然想用命名空间了，起码我是不想写那么长的类名。&lt;/p&gt;

&lt;p&gt;可喜的是Yaf只需要一条配置就可以爽快的支持PSR-4规范的命名空间。
可惜的是Yaf的这条配置是全局的，如果你的应用和别的应用公用PHP配置，而别人不用，那就没办法了。&lt;/p&gt;

&lt;p&gt;这条配置就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;;php.ini
yaf.use_namespace=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;

&lt;p&gt;我们都需要Http类吧，假设我写个HttpFoundation\Request类，可以在&lt;code&gt;library&lt;/code&gt;下新建&lt;code&gt;HttpFoundation&lt;/code&gt;目录，在其中新建&lt;code&gt;Request.php&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// HttpFoundation/Request.php
namespace HttpFoundation;

class Request
{
	public function get()
	{
		echo &amp;quot;I am going to send a GET request&amp;quot;;
		exit;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就注册了一个&lt;code&gt;HttpFoundation\Request&lt;/code&gt;类，在Controller中使用它只需要这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Yaf\Controller_Abstract;
use HttpFoundation\Request;

class FooController extends Controller_Abstract
{
	public function barAction()
	{
		$request = new Request();
		$request-&amp;gt;get();
		exit;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;再远一点&#34;&gt;再远一点？&lt;/h3&gt;

&lt;p&gt;是不是感受到了鸟哥的高瞻远瞩？其实我们还可以想的更多一点，既然可以自己写个HttpFoundation包了，你有没有想到Composer？因为多数时候这些基础类库都有现成的，用Composer安装就好，既然Yaf已经提供了性能好于autoloader的Yaf_Loader，何乐而不用呢？你甚至都可以引入第三方的ORM，比如Doctrine，第三方模板引擎Twig——对，没错，我就是Symfony的粉丝。&lt;/p&gt;

&lt;h2 id=&#34;目录结构设置&#34;&gt;目录结构设置&lt;/h2&gt;

&lt;p&gt;读一下Yaf源代码就特别清晰的看到默认的目录设置了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── application
│   ├── Bootstrap.php
│   ├── controllers
│   │   ├── Another.php
│   │   └── Index.php
│   ├── library
│   │   ├── Helper
│   │   └── HttpFoundation
│   │       └── Request.php
│   ├── models
│   ├── modules
│   │   └── Foo
│   │       └── controllers
│   │           └── Foo.php
│   ├── plugins
│   └── views
├── conf
│   ├── app.ini
│   └── db.ini
└── public
    └── index.php
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;application&lt;/p&gt;

&lt;p&gt;这是应用的主目录。&lt;/p&gt;

&lt;p&gt;想让应用能最简单的跑起来，得有Controller，也就是controllers目录，这里面放的是IndexModule的东西。&lt;/p&gt;

&lt;p&gt;底层用到的一些类库，放在library里。&lt;/p&gt;

&lt;p&gt;数据库操作放在models里。&lt;/p&gt;

&lt;p&gt;多模块放在modules里。像上面的树图里一样，每个module里还有相应的Controller。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;conf&lt;/p&gt;

&lt;p&gt;存放配置文件。&lt;/p&gt;

&lt;p&gt;我看多数时候是把它放在application里的，但我更倾向于把它放在和application同级目录下。其中的app.ini是Yaf框架的基础配置，里面需要包含Yaf的『唯一一个』必选配置项&lt;code&gt;application.directory&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;public&lt;/p&gt;

&lt;p&gt;存放index.php和静态文件。&lt;/p&gt;

&lt;p&gt;这里是用户可以直接访问的文件。静态文件放在这里最合适不过了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;插件的使用&#34;&gt;插件的使用&lt;/h2&gt;

&lt;p&gt;应用上线后Nginx的配置就不太好改了，但我们可以随意修改代码啊，所以如果需要对路由规则做一些修改，可以写个插件。下面以Route插件为例，介绍插件的使用。&lt;/p&gt;

&lt;h3 id=&#34;新建插件&#34;&gt;新建插件&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;application/plugins&lt;/code&gt;目录里新建&lt;code&gt;Route.php&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Yaf\Plugin_Abstract;
use Yaf\Request_Abstract;
use Yaf\Response_Abstract;

class RoutePlugin extends Plugin_Abstract
{
	public function routerStartup(Request_Abstract $request, Response_Abstract $response)
	{
		// some logic here
		$request-&amp;gt;setModule(&#39;foo&#39;);
		$request-&amp;gt;setController(&#39;bar&#39;);
		$request-&amp;gt;setAction(&#39;doge&#39;);
	}
	....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;注册插件&#34;&gt;注册插件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Bootstrap.php

use Yaf\Bootstrap_Abstract;
use Yaf\Dispatcher;

class Bootstrap extends Bootstrap_Abstract
{
	public function _initPlugin(Dispatcher $dispatcher)
	{
		$dispatcher-&amp;gt;regiserPlugin(new RouterPlugin());
	}
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候你可以试一下，所有请求都会被路由到FooModule/BarController/dogeAction了。&lt;/p&gt;

&lt;h2 id=&#34;单controller多action配置&#34;&gt;单Controller多Action配置&lt;/h2&gt;

&lt;p&gt;这个问题困扰我最久，最不理解的就是为什么要一个Controller里面只有一个indexAction，然后其他的路由还需要传一个action参数来自己做路由。其实默认的Yaf_Route_Static自己就支持这种写法的。只要保证&lt;code&gt;application.dispatcher.defaultRoute&lt;/code&gt;的值为空或&lt;code&gt;static&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;多模块配置&#34;&gt;多模块配置&lt;/h2&gt;

&lt;p&gt;在目录结构设置一节中已经说过怎么创建多模块。那么多模块有什么用呢？&lt;/p&gt;

&lt;p&gt;假设我们要做一个后台，不同模块是需要不同的访问权限的，该怎么办？我的想法是这样，做一个权限控制的plugin，先检查用户身份，然后&lt;code&gt;$request-&amp;gt;getModule()&lt;/code&gt;，如果要访问的是该用户不具有权限的模块，就给跳到一个403页。&lt;/p&gt;

&lt;h2 id=&#34;配置分节&#34;&gt;配置分节&lt;/h2&gt;

&lt;p&gt;假设这样一个场景，你线上和线下资源配置肯定是不一样的，但又有些是一样的，怎么办？还以&lt;code&gt;db.ini&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[db]
adapter=pdo_mysql

[prod:db]
host=&amp;quot;DB_HOST&amp;quot;
port=&amp;quot;DB_PORT&amp;quot;

[dev:prod]
host=&amp;quot;DB_HOST_DEV&amp;quot;
port=&amp;quot;DB_PORT_DEV&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况下可以写一个工具类，因为我觉得这个Yaf\Config\Ini提供的API并不太好用，先要初始化才能用。我做一层封装，不成想竟然发现了很方便的从生产环境/开发环境/测试环境的方法。工具类如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
namespace Your\Name\Space;
use Yaf\Config\Ini;

class Conf
{
    public static function get($key)
    {
        $filename = PATH/TO/CONF . &#39;/&#39; . explode(&#39;.&#39;, $key) . &#39;.ini&#39;;

        if (is_file($filename) &amp;amp;&amp;amp; is_readable($filename)) {
            $config = (new Ini($filename, ENV))-&amp;gt;get($key);
            if (is_a($config, &#39;Yaf\Config\Ini&#39;)) {
                $config = $config-&amp;gt;toArray();
            }
        } else {
            $config = null;
        }

        return $config;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个工具类的作用是支持&lt;code&gt;Your\Name\Space\Conf::get(&#39;foo.bar.good&#39;);&lt;/code&gt;的方式取值。如果配置文件是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[test]
foo.bar.good = &#39;good foo&#39;
foo.bar.better = &#39;better foo&#39;

[prod:test]
foo.bar.better = &#39;best foo&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那用&lt;code&gt;Your\Name\Space\Conf::get(&#39;foo.bar&#39;);&lt;/code&gt;取出的就是包含&lt;code&gt;good&lt;/code&gt;和&lt;code&gt;better&lt;/code&gt;的一个数组，如果是&lt;code&gt;Your\Name\Space\Conf::get(&#39;foo.bar.good&#39;);&lt;/code&gt;这样，就是&lt;code&gt;good foo&lt;/code&gt;这个字符串。&lt;/p&gt;

&lt;p&gt;重点是对生产环境的切换。注意实例化&lt;code&gt;Ini&lt;/code&gt;类的时候的那个&lt;code&gt;ENV&lt;/code&gt;变量，你可以在&lt;code&gt;/public/index.php&lt;/code&gt;中&lt;code&gt;define&lt;/code&gt;这个常量，然后又从一个公共的工具类中取出配置，所以只需要在修改&lt;code&gt;index.php&lt;/code&gt;里面的&lt;code&gt;ENV&lt;/code&gt;的定义，就可以方便的在各种环境之间切换了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>创建一个PSR-4规范的composer包</title>
      <link>http://lovelock.coding.me/php/2016-01-14-create-a-composer-package/</link>
      <pubDate>Sat, 09 Jan 2016 21:11:33 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/2016-01-14-create-a-composer-package/</guid>
      <description>

&lt;h3 id=&#34;下载安装composer&#34;&gt;下载安装Composer&lt;/h3&gt;

&lt;p&gt;到&lt;a href=&#34;https://getcomposer.org/download/&#34;&gt;composer官网&lt;/a&gt;按照指示下载。官方建议的是用&lt;code&gt;curl -sS https://getcomposer.org/installer | php&lt;/code&gt;这条命令。可能有些同学会迷惑这是在干什么，这其实是为了保证你下载到的总是最新的composer。分析一下，首先看到了管道，把前面curl获取的结果交给php执行，执行的结果就是下载了一个最新的&lt;code&gt;composer.phar&lt;/code&gt;到当前目录下。这时虽然也可以说已经能用了，但通常我还会把它链接到&lt;code&gt;/usr/local/bin&lt;/code&gt;目录下，方便使用。
&lt;code&gt;sudo ln -s /home/frost/packages/composer.phar /usr/local/bin/composer&lt;/code&gt;
这时在终端输入&lt;code&gt;composer&lt;/code&gt;就应该能看到它的帮助信息了。&lt;/p&gt;

&lt;h3 id=&#34;配置packagist&#34;&gt;配置Packagist&lt;/h3&gt;

&lt;p&gt;原本这不是必需的，但由于众所周知的原因，我还是建议配置一下。具体见&lt;a href=&#34;http://pkg.phpcomposer.com/&#34;&gt;这里&lt;/a&gt;。
&lt;code&gt;composer config -g repositories.packagist composer http://packagist.phpcomposer.com&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h2 id=&#34;composer-json&#34;&gt;composer.json&lt;/h2&gt;

&lt;p&gt;简单起见，这里使用monolog/monolog为例。
要使用composer，首先需要一个&lt;code&gt;composer.json&lt;/code&gt;文件，它描述了项目依赖关系及其他一些元信息。&lt;/p&gt;

&lt;h3 id=&#34;require-关键字&#34;&gt;&lt;code&gt;require&lt;/code&gt;关键字&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt;可能是你第一个也是唯一需要制定的东西。它用来告诉Composer你的项目需要依赖哪些包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;require&amp;quot;: {
		&amp;quot;monolog/monolog&amp;quot;: &amp;quot;1.0.*&amp;quot;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，&lt;code&gt;require&lt;/code&gt;接受一个包含包名(monolog/monolog)和版本限制(1.0.*)的映射的对象。&lt;/p&gt;

&lt;h3 id=&#34;包名&#34;&gt;包名&lt;/h3&gt;

&lt;p&gt;包名由vendor名和项目名组成。两者经常会是相同的——vendor名的存在只是为了避免名称冲突。它可以允许两个人创建同一个名称的库&lt;code&gt;json&lt;/code&gt;，这样两个包名就可能是&lt;code&gt;igorw/json&lt;/code&gt;和&lt;code&gt;seldaek/json&lt;/code&gt;了。
这里我们“需要”&lt;code&gt;monolog/monolog&lt;/code&gt;，所以vendor名和项目名一样。建议对项目使用唯一的名字。稍后还允许同一个命名空间下的多个项目。如果你在维护一个库，这可以让你很容易的把它分成多个解耦的小部分。&lt;/p&gt;

&lt;h3 id=&#34;包版本&#34;&gt;包版本&lt;/h3&gt;

&lt;p&gt;上面的例子中我们“需要”版本&lt;code&gt;1.0.*&lt;/code&gt;，这表示&lt;code&gt;1.0&lt;/code&gt;版本的所有分支。
版本限制可以用多种不同的方式，&lt;a href=&#34;https://getcomposer.org/doc/articles/versions.md&#34;&gt;这里&lt;/a&gt;给出了详细的解释。&lt;/p&gt;

&lt;h3 id=&#34;稳定性&#34;&gt;稳定性&lt;/h3&gt;

&lt;p&gt;默认情况下只考虑稳定版本。如果你也希望用RC, beta, alpha或者开发版，可以用&lt;a href=&#34;https://getcomposer.org/doc/04-schema.md#package-links&#34;&gt;稳定性标识&lt;/a&gt;。为了不用为每个包单独设置稳定性标识，还可以用&lt;a href=&#34;https://getcomposer.org/doc/04-schema.md#minimum-stability&#34;&gt;最小稳定性&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h3&gt;

&lt;p&gt;要安装依赖，只需要执行&lt;code&gt;composer install&lt;/code&gt;即可。
这会找到符合版本限制的最新版本的&lt;code&gt;monolog/monolog&lt;/code&gt;，并且把它下载到&lt;code&gt;vendor&lt;/code&gt;目录。把第三方的代码放在一个名为&lt;code&gt;vendor&lt;/code&gt;的目录是一个规范。在本例中，会把它放在&lt;code&gt;vendor/monolog/monolog&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你使用git，通常会把&lt;code&gt;vendor&lt;/code&gt;目录放在&lt;code&gt;.gitignore&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你会注意到&lt;code&gt;composer install&lt;/code&gt;命令还会在当前目录下生成一个&lt;code&gt;composer.lock&lt;/code&gt;文件。&lt;/p&gt;

&lt;h3 id=&#34;composer-lock-锁文件&#34;&gt;&lt;code&gt;composer.lock&lt;/code&gt;锁文件&lt;/h3&gt;

&lt;p&gt;安装完依赖后，Composer会把它安装的精确版本号写入&lt;code&gt;composer.lock&lt;/code&gt;文件中。它把项目锁定在某个特定的版本号。
把&lt;code&gt;composer.lock&lt;/code&gt;文件和&lt;code&gt;composer.json&lt;/code&gt;一起提交到版本控制中。这很重要，因为&lt;code&gt;install&lt;/code&gt;命令会检查锁文件是否存在，如果存在，它就会下载指定的精确版本，否则就会按照&lt;code&gt;composer.json&lt;/code&gt;的描述下载符合约束的最新版本。
这意味着每个下载了你的项目的人看到的都是&lt;strong&gt;完全&lt;/strong&gt;相同的代码，不会因为依赖更新了就自动更新依赖。&lt;code&gt;update&lt;/code&gt;命令会将依赖更新到符合要求的最新版本，然后更新锁文件。
&lt;code&gt;update&lt;/code&gt;命令也可以指定单独的包名来更新指定的包。&lt;/p&gt;

&lt;h3 id=&#34;packagist&#34;&gt;Packagist&lt;/h3&gt;

&lt;p&gt;Packagist是Composer的信息库。一个Composer信息库本质上是一个包的源——从这里你可以获取包。Packagist希望成为每个人用的中心信息库。这意味着你可以自动&lt;code&gt;require&lt;/code&gt;任何这里存在的包。&lt;/p&gt;

&lt;h3 id=&#34;自动加载&#34;&gt;自动加载&lt;/h3&gt;

&lt;p&gt;对于指定了自动加载信息的库，Composer会生成一个&lt;code&gt;vendor/autoload.php&lt;/code&gt;文件。你可以放心的&lt;code&gt;include&lt;/code&gt;这个文件而Composer会完成剩下的工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;require __DIR__ . &#39;/vendor/autoload.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这让使用第三方代码很方便。比如，如果你的项目依赖Monolog，你可以马上开始使用它的类，它会被自动加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$log = new Monolog\Logger(&#39;name&#39;);
$log-&amp;gt;pushHandler(new Monolog\Handler\StreamHandler(&#39;app.log&#39;, Monolog\Logger::WARNING));
$log-&amp;gt;addWarning(&#39;FOO&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以把自己的代码添加到&lt;code&gt;composer.json&lt;/code&gt;的&lt;code&gt;autoload&lt;/code&gt;字段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;autoload&amp;quot;: {
		&amp;quot;psr-4&amp;quot;: {&amp;quot;Acme\\&amp;quot;: &amp;quot;src/&amp;quot;}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Composer就会为Acme命名空间注册一个PSR-4的自动加载器。
这里你定义の一个命名空间到目录的映射。&lt;code&gt;src&lt;/code&gt;目录会是你的项目的根目录，和&lt;code&gt;vendor&lt;/code&gt;在同级目录。比如文件&lt;code&gt;src/Foo.php&lt;/code&gt;包含&lt;code&gt;Acme\Foo&lt;/code&gt;类。
在添加了&lt;code&gt;autoload&lt;/code&gt;字段之后，需要重新运行&lt;code&gt;dump-autoload&lt;/code&gt;来重新生成&lt;code&gt;vendor/autoload.php&lt;/code&gt;文件。包含这个文件还会返回一个自动加载器的实例，你可以把返回值存储下来并且添加更多的命名空间。这在测试时会很有用。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$loader = require __DIR__ . &#39;/vender/autoload.php&#39;;
$loader-&amp;gt;add(&#39;Acme\\Test\\&#39;, __DIR__);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>xhprof方便的插入要检测的代码</title>
      <link>http://lovelock.coding.me/php/2015-11-25-xhprof-usage/</link>
      <pubDate>Wed, 25 Nov 2015 22:10:51 +0000</pubDate>
      
      <guid>http://lovelock.coding.me/php/2015-11-25-xhprof-usage/</guid>
      <description>&lt;p&gt;本文只是给自己搞的一个小封装做个入口。&lt;/p&gt;

&lt;p&gt;一次给同事写的一个接口做重构，上线以后发现性能恶化严重，导致了线上的严重问题，我马上想到用xhprof查一下问题，结果由于用的是Yaf框架，里面对一些目录结构做了错误的判断，导致用起来很不方便。所以在问题解决之后我想着把这个xhprof的web目录做成一个独立的vhost，这样用起来就方便了，由于和主体项目所使用的框架无关，也不会受到不良影响。&lt;/p&gt;

&lt;p&gt;这里只留个地址，看项目的README吧。有希望能继续改进的小伙伴可以联系我。
&lt;a href=&#34;https://github.com/lovelock/xhprof-web.git&#34;&gt;github&lt;/a&gt;
&lt;a href=&#34;https://git.coding.net/lovelock/xhprof-web.git&#34;&gt;coding.net&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP单元测试-02</title>
      <link>http://lovelock.coding.me/php/2015-09-26-PHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-02/</link>
      <pubDate>Sat, 26 Sep 2015 10:41:42 +0000</pubDate>
      
      <guid>http://lovelock.coding.me/php/2015-09-26-PHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-02/</guid>
      <description>

&lt;p&gt;上一篇中讲了PHP单元测试的一些简单概念，这里详细说一下会用到的各种&lt;code&gt;assert*&lt;/code&gt;函数。官方文档按照字母顺序逐一讲述了这些方法，但我觉得那很不合适，至少应该大概按照类别来分类。&lt;/p&gt;

&lt;h2 id=&#34;数组相关&#34;&gt;数组相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertArrayHasKey($expected_key, $actual_array)&lt;/code&gt;
如果&lt;code&gt;$expected_key&lt;/code&gt;是&lt;code&gt;$actual_array&lt;/code&gt;中元素的一个键值，则通过，否则不通过。也即&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;foreach ($actual_array as $k =&amp;gt; $v) {
    if ($k === $expected_key) {
        // 测试通过
        return true;
    }
    // 测试不通过
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertArraySubset($subset_array, $actual_array)&lt;/code&gt;
如果&lt;code&gt;$subset_array&lt;/code&gt;是&lt;code&gt;$actual_array&lt;/code&gt;的一个子数组，则通过，否则不通过。也即前者是后者的&lt;strong&gt;子集&lt;/strong&gt;，这点很重要，其实由于在PHP中数组是作为HashTable存储的，所以是一般并不存在顺序的问题。因此这里只要求前者是后者的子集，而至于顺序则不要求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertCount($count, $array)&lt;/code&gt;
如果&lt;code&gt;count($array) === $count)&lt;/code&gt;则通过。注意这里&lt;code&gt;$count&lt;/code&gt;的类型必须是整数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;类属性相关&#34;&gt;类属性相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertClassHasAttribute($attributeName, $className)&lt;/code&gt;
如果类名为&lt;code&gt;$className&lt;/code&gt;的类拥有一个名为&lt;code&gt;$attributeName&lt;/code&gt;的属性，则通过，否则不通过。值得注意的是，这个测试通过与否与属性的值是否设置没有关系，即使是只声明了名为&lt;code&gt;$attributeName&lt;/code&gt;的属性，这个测试也是通过的，但实例化该类之后&lt;code&gt;var_dump(new ClassAttr()-&amp;gt;attr)&lt;/code&gt;的结果却是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assetClassHasStaticAttribute($staticAttributeName, $className)&lt;/code&gt;
这个自不必多说，和上面类似。只是用来判断静态属性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;对象关系&#34;&gt;对象关系&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;assertObjectHasAttribute($attributeName, $object)&lt;/code&gt;
如果对象&lt;code&gt;$object&lt;/code&gt;拥有属性&lt;code&gt;$attributeName&lt;/code&gt;，则通过。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;包含关系&#34;&gt;包含关系&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertContains($needle, $haystack)&lt;/code&gt;
如果&lt;code&gt;$haystack&lt;/code&gt;中包含&lt;code&gt;$needle&lt;/code&gt;，则通过，否则不通过。这个包含可以是数组的包含，也可以是字符串的包含，注意，默认是区分大小写的，即&lt;code&gt;assertContains(&#39;foo&#39;, &#39;FooBar&#39;)&lt;/code&gt;是不能通过测试的。但&lt;code&gt;assertContains(&#39;foo&#39;, &#39;FooBar&#39;, &#39;&#39;, true)&lt;/code&gt;则可以通过测试，也就是说第四个参数表示不区分大小写。至于第三个参数，其实是&lt;code&gt;$message&lt;/code&gt;，也就是在测试不通过时报告
详细信息的，我个人理解和&lt;code&gt;try/cache&lt;/code&gt;里面的&lt;code&gt;Exception $e&lt;/code&gt;里面的&lt;code&gt;getMessage()&lt;/code&gt;可能有点类似，没有深究。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertContainsOnly($type, $array)&lt;/code&gt;
如果&lt;code&gt;$array&lt;/code&gt;中只包含由&lt;code&gt;$type&lt;/code&gt;指定的一种类型的变量，则通过，否则不通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertContainsOnlyInstanceOf($className, $instance_array)&lt;/code&gt;
如果&lt;code&gt;$instance_array&lt;/code&gt;中的&lt;strong&gt;所有&lt;/strong&gt;元素都是名为&lt;code&gt;$className&lt;/code&gt;的类的实例，则通过，否则不通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertInstanceOf($className, $instance)&lt;/code&gt;
如果&lt;code&gt;$instance&lt;/code&gt;是&lt;code&gt;$className&lt;/code&gt;的实例，则通过。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;相等相关&#34;&gt;相等相关&lt;/h2&gt;

&lt;h3 id=&#34;是非问题&#34;&gt;是非问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;assertTrue($actual)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertFalse($actual)&lt;/code&gt;
上面两个判断的就是&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;，是&lt;code&gt;boolean&lt;/code&gt;类型的，而不是我们平时理解的存在或者值不为空等等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertNull($actual)&lt;/code&gt;
和上面两个一样，这个判断也是精确的，只有当&lt;code&gt;$actual === null&lt;/code&gt;时才通过。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;简单类型&#34;&gt;简单类型&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertEquals($expected, $actual)&lt;/code&gt;
如果&lt;code&gt;$expectec == $actual&lt;/code&gt;，则通过。注意这里的相等是和类型无关的，例如&lt;code&gt;assertEquals(1, &#39;1&#39;)&lt;/code&gt;是通过的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertSame($expected, $actual)&lt;/code&gt;
如果&lt;code&gt;$expected === $actual&lt;/code&gt;，则通过。注意这里的相等是需要类型也相同的，例如&lt;code&gt;assertSame(1, &#39;1&#39;)&lt;/code&gt;是不通过的。
当然以上两个都是可以判断数组的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertGreaterThan($expected, $actual)&lt;/code&gt; 和 &lt;code&gt;assertGreaterThanOrEqual($expected, $actual)&lt;/code&gt;
如果&lt;code&gt;$expected &amp;gt; $actual&lt;/code&gt;则通过。后者比前者多包含了一个相等的情况。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertLessThan($expected, $actual)&lt;/code&gt; 和 &lt;code&gt;assertLessThanOrEqual($expected, $actual)&lt;/code&gt;
如果&lt;code&gt;$expected &amp;lt; $actual&lt;/code&gt;则通过。后者比前者多包含了一个相等的情况。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertInternalType($type, $actual)&lt;/code&gt;
如果&lt;code&gt;gettype($actual) === $type&lt;/code&gt;，则通过。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;xml类型&#34;&gt;XML类型&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;assertEqualXmlStructure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertXmlFileEqualsXmlFile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertXmlStringEqualsXmlFile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertXmlStringEqualsXmlString&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;就我个人工作的经验来看，貌似XML在接口设计中已经很少见了，所以这里直接忽略吧，不喜欢XML。&lt;/p&gt;

&lt;h3 id=&#34;json类型&#34;&gt;JSON类型&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertJsonFileEqualsJsonFile($json_file1, $json_file2)&lt;/code&gt;
如果两个json内容相同，或者说包含的json格式可能不同(指空格、缩进等)，但值是相同的，则测试通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertJsonStringEqualsJsonFile($json_file, $json_encoded_string)&lt;/code&gt;
如果&lt;code&gt;$json_file&lt;/code&gt;中包含的JSON的内容和&lt;code&gt;$json_encoded_string&lt;/code&gt;一样，则通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertJsonStringEquaslJsonString($json_string1, $json_string2)&lt;/code&gt;
同上。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;文件相关&#34;&gt;文件相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertFileExists($file)&lt;/code&gt;
如果&lt;code&gt;$file&lt;/code&gt;存在，则通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertStringMatchesFormat($format, $string)&lt;/code&gt;
如果&lt;code&gt;$string&lt;/code&gt;的内容符合&lt;code&gt;$format&lt;/code&gt;的格式，如&lt;code&gt;%s&lt;/code&gt;、&lt;code&gt;%i&lt;/code&gt;等，则通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertStringMatchesFormatFile(&#39;path/to/file&#39;, $string)&lt;/code&gt;
如果&lt;code&gt;$string&lt;/code&gt;的内容符合&lt;code&gt;path/to/file&lt;/code&gt;的文件中定义的格式，则通过。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;assertRegExp($pattern, $string)&lt;/code&gt;
如果&lt;code&gt;$string&lt;/code&gt;符合&lt;code&gt;$pattern&lt;/code&gt;的模式，则通过。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;字符串相关&#34;&gt;字符串相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;assertStringStartsWith($start, $string)&lt;/code&gt;
如果&lt;code&gt;$string&lt;/code&gt;以&lt;code&gt;$start&lt;/code&gt;开头，则通过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assertStringEndsWith($end, $string)&lt;/code&gt;
如果&lt;code&gt;$string&lt;/code&gt;以&lt;code&gt;$start&lt;/code&gt;结尾，则通过。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文就介绍这么多，主要参考了&lt;a href=&#34;https://phpunit.de/manual/current/en/appendixes.assertions.html&#34;&gt;phpunit.de&lt;/a&gt;，加上自己的理解，当然这远远不够全，最起码的是几乎每个方法都有相反的实现，例如&lt;code&gt;assertStringStartWidth&lt;/code&gt;，同时也有&lt;code&gt;assertStringNotStartWith&lt;/code&gt;， 但知道了一面的判断原则，另一面一定也可以触类旁通了。写了那么多，其实还是建议读者每条都自己写出来尝试下，多试试不同的
条件，自然就理解了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP单元测试-01</title>
      <link>http://lovelock.coding.me/php/2015-09-22-PHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-01/</link>
      <pubDate>Tue, 22 Sep 2015 15:49:52 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/2015-09-22-PHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-01/</guid>
      <description>

&lt;p&gt;我自认对这种比较系统的知识总是比较欠缺，所以还是花点时间补充上比较好。&lt;/p&gt;

&lt;p&gt;这里说一下PHP的单元测试。&lt;/p&gt;

&lt;p&gt;首先是搭建可以进行单元测试的环境，这里我首选的还是Debian Sid。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install phpunit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一条命令就可以安装单元测试所需要的各种依赖了，之所以选择这种可能不是最新的包的安装方式是因为pear(pecl)在国内的访问速度毕竟不怎么理想，既然我们有一个优秀的&lt;code&gt;apt&lt;/code&gt;了，何必还要费那劲呢？&lt;/p&gt;

&lt;h2 id=&#34;初识单元测试&#34;&gt;初识单元测试&lt;/h2&gt;

&lt;p&gt;首先，一个类对应一个测试类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── FrostWong.php
└── FrostWongTest.php

0 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// FrostWong.php

&amp;lt;?php

class FrostWong
{
    public function sayHi()
    {
        return &amp;quot;Hi, UnitTest.\n&amp;quot;;
    }

    public function altb($a, $b)
    {
        return $a &amp;gt; $b;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// FrostWongTest.php

&amp;lt;?php

require &#39;PHPUnit/Autoload.php&#39;;
require &#39;FrostWong.php&#39;;

class FrostWongTest extends PHPUnit_Framework_TestCase
{
    public function testSayHi()
    {
        $fw = new FrostWong();
        $this-&amp;gt;assertEquals(&amp;quot;Hi, UnitTest.\n&amp;quot;, $fw-&amp;gt;sayHi());
    }

    public function testAltb()
    {
        $fw = new FrostWong();
        $this-&amp;gt;assertTrue($fw-&amp;gt;altb(4, 3));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，就可以执行单元测试了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;phpunit FrostWongTest&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个命令有几个需要注意的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;命令行参数是&lt;code&gt;FrostWongTest&lt;/code&gt;而不是&lt;code&gt;FrostWongTest.php&lt;/code&gt;，这一点和命令行用&lt;code&gt;java&lt;/code&gt;执行&lt;code&gt;class&lt;/code&gt;文件时有异曲同工之妙：）。&lt;/li&gt;
&lt;li&gt;PHP执行包含路径的问题，检查你的&lt;code&gt;php.ini&lt;/code&gt;文件，看其中&lt;code&gt;include_path&lt;/code&gt;一行，看其中有没有包含&lt;code&gt;.&lt;/code&gt;，也就是当前路径。如果不包含，那么执行上面的语句时就会出现&lt;code&gt;Cannot open file FrostWongTest.php&lt;/code&gt;的错误，然后什么都不会发生。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;setup&#34;&gt;setUp&lt;/h2&gt;

&lt;p&gt;你一定也注意到了，因为被测试的类中有两个方法，所以就初始化了两次&lt;code&gt;FrostWong&lt;/code&gt;类，PHPUnit当然给我们提供了更好的方式，那就是&lt;code&gt;setUp&lt;/code&gt;，我理解的&lt;code&gt;setUp&lt;/code&gt;就是一个用来初始化需要的变量的模板方法。同样的还有&lt;code&gt;tearDown&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;所以上面测试用例的第二版就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

require &#39;PHPUnit/Autoload.php&#39;;
require &#39;FrostWong.php&#39;;

class FrostWongTest extends PHPUnit_Framework_TestCase
{
    function setUp()
    {
        $this-&amp;gt;fw = new FrostWong();
    }

    public function testSayHi()
    {
        $this-&amp;gt;assertEquals(&amp;quot;Hi, UnitTest.\n&amp;quot;, $this-&amp;gt;fw-&amp;gt;sayHi());
    }

    public function testAltb()
    {
        $this-&amp;gt;assertTrue($this-&amp;gt;fw-&amp;gt;altb(4, 3));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，现在你一定已经对PHP端单元测试有了大致的印象了，下一篇会讲一些常用的&lt;code&gt;assert&lt;/code&gt;方法，来进行实际的操练。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>缓存使用小记</title>
      <link>http://lovelock.coding.me/php/2015-06-26-huan-cun-shi-yong-xiao-ji/</link>
      <pubDate>Fri, 26 Jun 2015 10:24:03 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/2015-06-26-huan-cun-shi-yong-xiao-ji/</guid>
      <description>&lt;p&gt;在请求次数多的业务系统中，通常会加入缓存系统。这里用的较多的就是Memcached和Redis。我写这篇笔记不是要说这两个缓存的使用细节，而是缓存使用的注意事项。&lt;/p&gt;

&lt;p&gt;首先要清楚，这两个缓存数据库不是安装上就万事大吉了，它是不会主动地帮你解决任何问题的。那么何时把数据存入(更新)缓存，何时取出缓存中的数据？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;存入数据
假设原来的系统中有一条插入或者更新数据库的操作，缓存的操作就应该放在数据库操作完成之后，并且要确定数据库的更新成功了，&lt;strong&gt;然后再写入缓存&lt;/strong&gt;。这里是为了保证数据的一致性，即防止虽然发送了写入数据库的请求，但请求没有成功，结果缓存却成功的写入了，那么这时缓存和数据库的数据就不一致了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;读取缓存
同样的原理，假设原来的系统中有一条查询数据库的操作，缓存的操作就应该放在数据库操作之前，并且如果缓存的数据存在，就&lt;strong&gt;直接返回不再操作数据库&lt;/strong&gt;了。如果缓存的数据不存在，就去查询数据库，&lt;strong&gt;然后将结果存入缓存&lt;/strong&gt;。所谓缓存能提升性能的根本就在这里，我们知道数据库之所以经常是性能瓶颈就是因为它的IO操作占用大量时间，如果频繁地请求是发给了缓存，那么就能大量的减少数据库请求，有效提升系统性能。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结一下，有两处进行了更新缓存的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 更新数据库后
2. 查询缓存如果不存在，将从数据库中取出的结果存入缓存
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么为什么在查询数据库后要更新缓存呢？这就要想一下缓存为什么会不存在，通常我们会为缓存设置一个有效期，超过有效期缓存就会失效，也就是被删除了，所以如果缓存不存在，多半是过期的，这时如果不再设置一个缓存，那以后的每次请求又都会到数据库了。因此可以说，整个缓存系统有序的运行的初始化就是数据库的更新操作，而之后的每次更新其实是对数据库的查询请求发起的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP设置cookie</title>
      <link>http://lovelock.coding.me/php/2015-06-19-phpshe-zhi-cookie/</link>
      <pubDate>Fri, 19 Jun 2015 12:30:13 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/2015-06-19-phpshe-zhi-cookie/</guid>
      <description>&lt;p&gt;之前一直没有处理过cookie，刚才小小的看了一下，貌似很简单，大概记一下。&lt;/p&gt;

&lt;p&gt;首先，客户端要向服务端发送一个请求，服务端接收到请求之后做一下身份校验什么的，然后就可以给客户端种cookie了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;setcookie(&amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;, time()+expire);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;expire&lt;/code&gt;是cookie的过期时间，上面的例子用了两部分来说明它，time()获取当前的时间戳，那么&lt;code&gt;expire&lt;/code&gt;就是你希望这个cookie在当前时刻之后再存活的时间长短。&lt;/p&gt;

&lt;p&gt;那么如何手动删除cookie呢？答案是无法直接删除cookie。但可以设置其过期，这样就间接的把它删除了。那怎样设置过期呢？&lt;code&gt;setcookie&lt;/code&gt;的第三个参数设置的小于当前时间就可以了。&lt;/p&gt;

&lt;p&gt;那怎么用cookie呢？&lt;/p&gt;

&lt;p&gt;当你把cookie种到了客户端的机器上，它会保存在默认的域下，当客户端访问这个域下的资源时，发送的请求中会带着所有的cookie，然后在服务端用超全局变量&lt;code&gt;$_COOKIE[&#39;key&#39;]&lt;/code&gt;就可以直接访问它了。&lt;/p&gt;

&lt;p&gt;demo代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$username = $_GET[&#39;username&#39;];
$passwd = $_GET[&#39;passwd&#39;];

if (/* 身份校验成功 */) {
    setcookie(&amp;quot;username&amp;quot;, $username, time() + 3600);
    echo &amp;quot;cookie set&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$username = $_COOKIE[&amp;quot;username&amp;quot;];
echo &amp;quot;username: &amp;quot; . $username;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PHP延迟绑定</title>
      <link>http://lovelock.coding.me/php/2015-06-17-phpyan-chi-bang-ding/</link>
      <pubDate>Wed, 17 Jun 2015 23:37:38 +0800</pubDate>
      
      <guid>http://lovelock.coding.me/php/2015-06-17-phpyan-chi-bang-ding/</guid>
      <description>&lt;p&gt;在公司的代码里看到很多重复代码，每张表对应的类都有一个一样的静态方法，作用是获得数据库的连接。但显然这并不是一个好的解决方案，而应该充分利用面向对象的思想，利用继承的方式来更优雅的解决。&lt;/p&gt;

&lt;p&gt;我想，当初作者在写这部分代码的时候可能也已经考虑到了这个问题，但很可能是对PHP的延后绑定（LSB）不了解，因此没有实施。&lt;/p&gt;

&lt;p&gt;得到数据库连接的实例有多种方式，这里我们假设有一个方法&lt;code&gt;DB::mysqlConn($tableName);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;举个例子来说，假设我们设计一个基类&lt;code&gt;BaseConn&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class BaseConn
{
    protected static $conn;
    protected static $tableName;
    
    public function getInstance()
    {
        self::$conn = DB::mysqlConn($tableName);
        return self::$conn;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照计划，我们就可以写子类了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class ATableConn extends BaseConn
{
    protected static $tableName = &#39;atable&#39;;
    
    public static findById($id)
    {
        $query = &amp;quot;select * from &amp;quot; . self::$tableName . &amp;quot; where id = {$id}&amp;quot;;
        return $this-&amp;gt;getInstance()-&amp;gt;exec($sql);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时一般都会认为没有什么问题了，因为我们已经在子类里设定了&lt;code&gt;$tableName&lt;/code&gt;的值，这样在创建数据库连接的时候一定就是&lt;code&gt;atable&lt;/code&gt;的连接了。&lt;/p&gt;

&lt;p&gt;错！&lt;/p&gt;

&lt;p&gt;因为用&lt;code&gt;self&lt;/code&gt;关键字绑定到了编译时引用的属性或方法。&lt;code&gt;self&lt;/code&gt;关键字指向的是父类，而且不会意识到子类，基本上，编译器会用所绑定的名称替换&lt;code&gt;self&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;那么怎么解决呢？PHP5.3为一个本来就存在的关键字赋予了新的含义——&lt;code&gt;static&lt;/code&gt;，它会在可能的最近时刻强迫PHP绑定到实现代码。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:static&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:static&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;因此，把上面代码中&lt;code&gt;getInstance&lt;/code&gt;方法中的&lt;code&gt;self&lt;/code&gt;替换成&lt;code&gt;static&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;p&gt;这个特性也就可以实现ActiveRecord了，不过这就是另外一个话题了。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:static&#34;&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/opensource/os-php-53static/&#34;&gt;PHP V5.3 用延后静态绑定搞活面向对象编程&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:static&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
